---
phase: 01-cryptographic-foundation-packaging
plan: 05
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - frontend/src/lib/pywebview.ts
  - frontend/src/stores/identity.ts
  - frontend/src/stores/contacts.ts
  - frontend/src/stores/ui.ts
  - frontend/src/components/theme-provider.tsx
  - frontend/src/components/layout/Sidebar.tsx
  - frontend/src/components/layout/MainPanel.tsx
  - frontend/src/components/layout/AppLayout.tsx
  - frontend/src/App.tsx
  - frontend/src/index.css
  - frontend/tailwind.config.ts
autonomous: true

must_haves:
  truths:
    - "React app waits for pywebviewready before using API"
    - "Dark cosmic theme is applied by default"
    - "Sidebar and main panel layout is visible"
    - "Zustand stores manage identity and contacts state"
  artifacts:
    - path: "frontend/src/lib/pywebview.ts"
      provides: "Type-safe PyWebView API client"
      exports: ["api", "waitForPyWebView"]
    - path: "frontend/src/stores/identity.ts"
      provides: "Identity state management"
      exports: ["useIdentityStore"]
    - path: "frontend/src/components/layout/AppLayout.tsx"
      provides: "Main application layout"
      min_lines: 30
  key_links:
    - from: "frontend/src/lib/pywebview.ts"
      to: "window.pywebview.api"
      via: "pywebviewready event listener"
      pattern: "pywebviewready"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/lib/pywebview.ts"
      via: "waitForPyWebView on mount"
      pattern: "waitForPyWebView"
---

<objective>
Build React UI shell with PyWebView bridge, dark cosmic theme, and layout structure.

Purpose: Establish the frontend foundation - the PyWebView bridge for Python communication, Zustand stores for state, and the basic layout (sidebar + main panel). This validates the Python-React integration early.

Output: Working React app with dark theme and layout structure.
</objective>

<execution_context>
@C:\Users\thete\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thete\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cryptographic-foundation-packaging/01-RESEARCH.md
@.planning/phases/01-cryptographic-foundation-packaging/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PyWebView Bridge and Zustand Stores</name>
  <files>
    frontend/src/lib/pywebview.ts
    frontend/src/stores/identity.ts
    frontend/src/stores/contacts.ts
    frontend/src/stores/ui.ts
  </files>
  <action>
Create PyWebView API client and Zustand state stores:

1. Create `frontend/src/lib/pywebview.ts`:
```typescript
/**
 * Type-safe PyWebView API client.
 *
 * CRITICAL: Use waitForPyWebView() before calling any API methods.
 * The pywebview.api object is injected asynchronously and may not
 * exist when window.onload fires.
 */

// Type definitions for Python API methods
export interface PyWebViewAPI {
  // Identity
  get_identity(): Promise<IdentityResponse | null>;
  generate_identity(display_name: string): Promise<IdentityResponse>;
  update_display_name(name: string): Promise<void>;

  // Backup
  export_backup(password: string): Promise<string>;
  import_backup(backup_json: string, password: string): Promise<IdentityResponse>;

  // Contacts
  get_contacts(): Promise<ContactResponse[]>;
  add_contact(public_key: string, display_name: string): Promise<ContactResponse>;
  remove_contact(id: number): Promise<void>;
  set_contact_verified(id: number, verified: boolean): Promise<void>;

  // System
  ping(): Promise<string>;
}

export interface IdentityResponse {
  publicKey: string;
  fingerprint: string;
  displayName: string;
}

export interface ContactResponse {
  id: number;
  publicKey: string;
  fingerprint: string;
  displayName: string;
  verified: boolean;
  addedAt: string;
}

// Declare global window type extension
declare global {
  interface Window {
    pywebview?: {
      api: PyWebViewAPI;
    };
  }
}

// Promise that resolves when PyWebView is ready
let pywebviewReadyPromise: Promise<void> | null = null;

/**
 * Wait for PyWebView API to be available.
 * Call this before using the api object.
 */
export function waitForPyWebView(): Promise<void> {
  if (pywebviewReadyPromise) {
    return pywebviewReadyPromise;
  }

  pywebviewReadyPromise = new Promise((resolve) => {
    if (window.pywebview?.api) {
      // Already available
      resolve();
      return;
    }

    // Wait for pywebviewready event
    window.addEventListener('pywebviewready', () => {
      resolve();
    });
  });

  return pywebviewReadyPromise;
}

/**
 * Get the PyWebView API.
 * MUST call waitForPyWebView() first.
 */
export function getApi(): PyWebViewAPI {
  if (!window.pywebview?.api) {
    throw new Error(
      'PyWebView API not available. Call waitForPyWebView() first.'
    );
  }
  return window.pywebview.api;
}

// Convenience export
export const api = {
  /**
   * Call an API method safely.
   * Waits for PyWebView and handles errors.
   */
  async call<T>(method: (api: PyWebViewAPI) => Promise<T>): Promise<T> {
    await waitForPyWebView();
    return method(getApi());
  },
};
```

2. Create `frontend/src/stores/identity.ts`:
```typescript
import { create } from 'zustand';
import type { IdentityResponse } from '@/lib/pywebview';

interface IdentityState {
  identity: IdentityResponse | null;
  isLoading: boolean;
  error: string | null;

  setIdentity: (identity: IdentityResponse | null) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  clear: () => void;
}

export const useIdentityStore = create<IdentityState>((set) => ({
  identity: null,
  isLoading: true,
  error: null,

  setIdentity: (identity) => set({ identity, isLoading: false, error: null }),
  setLoading: (isLoading) => set({ isLoading }),
  setError: (error) => set({ error, isLoading: false }),
  clear: () => set({ identity: null, isLoading: false, error: null }),
}));
```

3. Create `frontend/src/stores/contacts.ts`:
```typescript
import { create } from 'zustand';
import type { ContactResponse } from '@/lib/pywebview';

interface ContactsState {
  contacts: ContactResponse[];
  isLoading: boolean;
  error: string | null;

  setContacts: (contacts: ContactResponse[]) => void;
  addContact: (contact: ContactResponse) => void;
  removeContact: (id: number) => void;
  updateContact: (id: number, updates: Partial<ContactResponse>) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
}

export const useContactsStore = create<ContactsState>((set) => ({
  contacts: [],
  isLoading: true,
  error: null,

  setContacts: (contacts) => set({ contacts, isLoading: false, error: null }),

  addContact: (contact) =>
    set((state) => ({
      contacts: [...state.contacts, contact],
    })),

  removeContact: (id) =>
    set((state) => ({
      contacts: state.contacts.filter((c) => c.id !== id),
    })),

  updateContact: (id, updates) =>
    set((state) => ({
      contacts: state.contacts.map((c) =>
        c.id === id ? { ...c, ...updates } : c
      ),
    })),

  setLoading: (isLoading) => set({ isLoading }),
  setError: (error) => set({ error, isLoading: false }),
}));
```

4. Create `frontend/src/stores/ui.ts`:
```typescript
import { create } from 'zustand';

type Panel = 'chat' | 'settings';

interface UIState {
  activePanel: Panel;
  selectedContactId: number | null;
  isSidebarCollapsed: boolean;

  setActivePanel: (panel: Panel) => void;
  setSelectedContact: (id: number | null) => void;
  toggleSidebar: () => void;
}

export const useUIStore = create<UIState>((set) => ({
  activePanel: 'chat',
  selectedContactId: null,
  isSidebarCollapsed: false,

  setActivePanel: (activePanel) => set({ activePanel }),
  setSelectedContact: (selectedContactId) => set({ selectedContactId }),
  toggleSidebar: () =>
    set((state) => ({ isSidebarCollapsed: !state.isSidebarCollapsed })),
}));
```

NOTE: Stores are intentionally simple - they manage state, not API calls. Components will use api.call() directly.
  </action>
  <verify>
    TypeScript compiles: `cd frontend && npx tsc --noEmit`
    Stores exist: `ls frontend/src/stores/*.ts`
  </verify>
  <done>
    - PyWebView client with waitForPyWebView() for safe API access
    - Identity store with identity state and loading/error handling
    - Contacts store with CRUD operations
    - UI store with panel navigation and sidebar state
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Dark Cosmic Theme and Layout Components</name>
  <files>
    frontend/src/components/theme-provider.tsx
    frontend/src/components/layout/Sidebar.tsx
    frontend/src/components/layout/MainPanel.tsx
    frontend/src/components/layout/AppLayout.tsx
    frontend/src/index.css
    frontend/tailwind.config.ts
  </files>
  <action>
Create theme provider and layout components:

1. Create `frontend/tailwind.config.ts`:
```typescript
import type { Config } from 'tailwindcss';

export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        // Cosmic dark theme colors
        cosmic: {
          bg: '#0a0a0f',
          surface: '#12121a',
          border: '#1e1e2e',
          text: '#e1e1e6',
          muted: '#8b8b9a',
          accent: '#6366f1',
          'accent-hover': '#818cf8',
        },
      },
      animation: {
        'star-twinkle': 'twinkle 3s ease-in-out infinite',
      },
      keyframes: {
        twinkle: {
          '0%, 100%': { opacity: '0.3' },
          '50%': { opacity: '1' },
        },
      },
    },
  },
  plugins: [],
} satisfies Config;
```

2. Update `frontend/src/index.css`:
```css
@import 'tailwindcss';

@theme {
  --color-cosmic-bg: #0a0a0f;
  --color-cosmic-surface: #12121a;
  --color-cosmic-border: #1e1e2e;
  --color-cosmic-text: #e1e1e6;
  --color-cosmic-muted: #8b8b9a;
  --color-cosmic-accent: #6366f1;
  --color-cosmic-accent-hover: #818cf8;
}

html {
  @apply bg-cosmic-bg text-cosmic-text;
}

body {
  @apply min-h-screen bg-cosmic-bg text-cosmic-text antialiased;
  font-family: system-ui, -apple-system, sans-serif;
}

/* Scrollbar styling for cosmic theme */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  @apply bg-cosmic-bg;
}

::-webkit-scrollbar-thumb {
  @apply bg-cosmic-border rounded-full;
}

::-webkit-scrollbar-thumb:hover {
  @apply bg-cosmic-muted;
}

/* Starry background */
.starry-bg {
  background-image:
    radial-gradient(2px 2px at 20px 30px, #6366f1, transparent),
    radial-gradient(2px 2px at 40px 70px, #818cf8, transparent),
    radial-gradient(1px 1px at 90px 40px, #e1e1e6, transparent),
    radial-gradient(2px 2px at 130px 80px, #6366f1, transparent),
    radial-gradient(1px 1px at 160px 120px, #818cf8, transparent);
  background-repeat: repeat;
  background-size: 200px 150px;
}
```

3. Create `frontend/src/components/theme-provider.tsx`:
```tsx
import { createContext, useContext, useEffect, useState } from 'react';

type Theme = 'dark' | 'light' | 'system';

interface ThemeProviderState {
  theme: Theme;
  setTheme: (theme: Theme) => void;
}

const ThemeProviderContext = createContext<ThemeProviderState>({
  theme: 'dark',
  setTheme: () => null,
});

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>('dark');

  useEffect(() => {
    const root = document.documentElement;
    root.classList.remove('light', 'dark');
    root.classList.add(theme === 'system'
      ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
      : theme
    );
  }, [theme]);

  return (
    <ThemeProviderContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeProviderContext.Provider>
  );
}

export const useTheme = () => useContext(ThemeProviderContext);
```

4. Create `frontend/src/components/layout/Sidebar.tsx`:
```tsx
import { motion } from 'framer-motion';
import { useContactsStore } from '@/stores/contacts';
import { useUIStore } from '@/stores/ui';

export function Sidebar() {
  const contacts = useContactsStore((s) => s.contacts);
  const selectedContactId = useUIStore((s) => s.selectedContactId);
  const setSelectedContact = useUIStore((s) => s.setSelectedContact);
  const setActivePanel = useUIStore((s) => s.setActivePanel);

  return (
    <motion.aside
      initial={{ x: -20, opacity: 0 }}
      animate={{ x: 0, opacity: 1 }}
      className="w-64 h-full bg-cosmic-surface border-r border-cosmic-border flex flex-col"
    >
      {/* Header */}
      <div className="p-4 border-b border-cosmic-border">
        <h1 className="text-lg font-semibold text-cosmic-text">DiscordOpus</h1>
        <p className="text-xs text-cosmic-muted">Secure P2P Messenger</p>
      </div>

      {/* Contacts list */}
      <div className="flex-1 overflow-y-auto p-2">
        <div className="text-xs uppercase text-cosmic-muted px-2 py-1 mb-1">
          Contacts
        </div>
        {contacts.length === 0 ? (
          <p className="text-sm text-cosmic-muted px-2 py-4 text-center">
            No contacts yet
          </p>
        ) : (
          <ul className="space-y-1">
            {contacts.map((contact) => (
              <li key={contact.id}>
                <button
                  onClick={() => {
                    setSelectedContact(contact.id);
                    setActivePanel('chat');
                  }}
                  className={`w-full text-left px-2 py-2 rounded-md transition-colors ${
                    selectedContactId === contact.id
                      ? 'bg-cosmic-accent/20 text-cosmic-accent'
                      : 'hover:bg-cosmic-border text-cosmic-text'
                  }`}
                >
                  <div className="font-medium truncate">{contact.displayName}</div>
                  <div className="text-xs text-cosmic-muted truncate">
                    {contact.fingerprint.slice(0, 16)}...
                  </div>
                </button>
              </li>
            ))}
          </ul>
        )}
      </div>

      {/* Footer with settings */}
      <div className="p-2 border-t border-cosmic-border">
        <button
          onClick={() => setActivePanel('settings')}
          className="w-full px-3 py-2 text-left text-sm text-cosmic-muted hover:text-cosmic-text hover:bg-cosmic-border rounded-md transition-colors"
        >
          Settings
        </button>
      </div>
    </motion.aside>
  );
}
```

5. Create `frontend/src/components/layout/MainPanel.tsx`:
```tsx
import { motion } from 'framer-motion';
import { useUIStore } from '@/stores/ui';
import { useContactsStore } from '@/stores/contacts';

export function MainPanel() {
  const activePanel = useUIStore((s) => s.activePanel);
  const selectedContactId = useUIStore((s) => s.selectedContactId);
  const contacts = useContactsStore((s) => s.contacts);

  const selectedContact = contacts.find((c) => c.id === selectedContactId);

  return (
    <motion.main
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      className="flex-1 h-full bg-cosmic-bg flex flex-col overflow-hidden"
    >
      {activePanel === 'settings' ? (
        <div className="flex-1 p-6">
          <h2 className="text-xl font-semibold mb-4">Settings</h2>
          <p className="text-cosmic-muted">
            Settings panel will be implemented in the next plan.
          </p>
        </div>
      ) : selectedContact ? (
        <div className="flex-1 flex flex-col">
          {/* Chat header */}
          <div className="p-4 border-b border-cosmic-border">
            <h2 className="font-semibold">{selectedContact.displayName}</h2>
            <p className="text-xs text-cosmic-muted">
              {selectedContact.verified ? 'Verified' : 'Unverified'}
            </p>
          </div>
          {/* Chat messages - placeholder */}
          <div className="flex-1 p-4 overflow-y-auto">
            <p className="text-cosmic-muted text-center py-8">
              Chat functionality coming in Phase 3
            </p>
          </div>
          {/* Message input - placeholder */}
          <div className="p-4 border-t border-cosmic-border">
            <div className="bg-cosmic-surface rounded-lg p-3 text-cosmic-muted">
              Message input coming in Phase 3...
            </div>
          </div>
        </div>
      ) : (
        <div className="flex-1 flex items-center justify-center text-cosmic-muted">
          <div className="text-center">
            <p className="text-lg">Select a contact to start chatting</p>
            <p className="text-sm mt-2">Or add a new contact in Settings</p>
          </div>
        </div>
      )}
    </motion.main>
  );
}
```

6. Create `frontend/src/components/layout/AppLayout.tsx`:
```tsx
import { Sidebar } from './Sidebar';
import { MainPanel } from './MainPanel';

export function AppLayout() {
  return (
    <div className="flex h-screen w-screen overflow-hidden starry-bg">
      <Sidebar />
      <MainPanel />
    </div>
  );
}
```

NOTE: Settings panel content is a placeholder - it will be fully implemented in Plan 06.
  </action>
  <verify>
    TypeScript compiles: `cd frontend && npx tsc --noEmit`
    Components exist: `ls frontend/src/components/layout/*.tsx`
  </verify>
  <done>
    - Dark cosmic theme with custom colors in Tailwind config
    - Starry background CSS animation
    - ThemeProvider for future light mode support
    - Sidebar with contacts list and settings button
    - MainPanel with chat placeholder and settings placeholder
    - AppLayout combining sidebar and main panel
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire Up App and Verify Frontend Builds</name>
  <files>
    frontend/src/App.tsx
  </files>
  <action>
Update App.tsx to use the new components and verify build:

1. Update `frontend/src/App.tsx`:
```tsx
import { useEffect, useState } from 'react';
import { ThemeProvider } from '@/components/theme-provider';
import { AppLayout } from '@/components/layout/AppLayout';
import { waitForPyWebView, getApi } from '@/lib/pywebview';
import { useIdentityStore } from '@/stores/identity';
import { useContactsStore } from '@/stores/contacts';

function AppContent() {
  const [isReady, setIsReady] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const setIdentity = useIdentityStore((s) => s.setIdentity);
  const setIdentityLoading = useIdentityStore((s) => s.setLoading);
  const setContacts = useContactsStore((s) => s.setContacts);

  useEffect(() => {
    async function initialize() {
      try {
        // Wait for PyWebView bridge
        await waitForPyWebView();
        const api = getApi();

        // Load identity
        setIdentityLoading(true);
        const identity = await api.get_identity();
        setIdentity(identity);

        // Load contacts
        const contacts = await api.get_contacts();
        setContacts(contacts);

        setIsReady(true);
      } catch (err) {
        console.error('Initialization error:', err);
        setError(err instanceof Error ? err.message : 'Failed to initialize');
      }
    }

    initialize();
  }, [setIdentity, setIdentityLoading, setContacts]);

  if (error) {
    return (
      <div className="flex items-center justify-center h-screen bg-cosmic-bg text-red-400">
        <div className="text-center p-8">
          <h1 className="text-xl font-semibold mb-2">Initialization Error</h1>
          <p className="text-cosmic-muted">{error}</p>
        </div>
      </div>
    );
  }

  if (!isReady) {
    return (
      <div className="flex items-center justify-center h-screen bg-cosmic-bg">
        <div className="text-center">
          <div className="w-8 h-8 border-2 border-cosmic-accent border-t-transparent rounded-full animate-spin mx-auto mb-4" />
          <p className="text-cosmic-muted">Loading DiscordOpus...</p>
        </div>
      </div>
    );
  }

  return <AppLayout />;
}

export default function App() {
  return (
    <ThemeProvider>
      <AppContent />
    </ThemeProvider>
  );
}
```

2. Verify frontend builds:
```bash
cd frontend && npm run build
```

3. Verify dist output contains assets:
```bash
ls frontend/dist/
ls frontend/dist/assets/
```

NOTE: The app will show a loading spinner until PyWebView bridge is ready. For development, it will error out since there's no Python backend running - that's expected at this stage.
  </action>
  <verify>
    Frontend builds: `cd frontend && npm run build && ls dist/index.html`
    No TypeScript errors: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
    - App.tsx initializes by waiting for PyWebView
    - Loading spinner shown during initialization
    - Error state handled gracefully
    - Frontend builds successfully to dist/
    - AppLayout rendered with sidebar and main panel
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Frontend builds without errors
2. PyWebView bridge client waits for pywebviewready
3. Zustand stores manage identity, contacts, and UI state
4. Dark cosmic theme applied with starry background
5. Sidebar + MainPanel layout visible in built app
</verification>

<success_criteria>
- `npm run build` succeeds in frontend/
- `npx tsc --noEmit` shows no TypeScript errors
- waitForPyWebView() uses pywebviewready event (not onload)
- Dark cosmic theme colors in Tailwind config
- Starry background animation in CSS
- Sidebar shows contacts list with Settings button
- MainPanel shows chat placeholder or settings placeholder
</success_criteria>

<output>
After completion, create `.planning/phases/01-cryptographic-foundation-packaging/01-05-SUMMARY.md`
</output>
