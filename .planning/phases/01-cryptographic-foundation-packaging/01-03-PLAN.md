---
phase: 01-cryptographic-foundation-packaging
plan: 03
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/crypto/__init__.py
  - src/crypto/identity.py
  - src/crypto/fingerprint.py
  - src/storage/identity_store.py
autonomous: true

must_haves:
  truths:
    - "User can generate Ed25519/X25519 key pair"
    - "Keys are stored DPAPI-encrypted in filesystem (not database)"
    - "Fingerprint is SHA256 of Ed25519 public key"
    - "Identity persists across application restarts"
  artifacts:
    - path: "src/crypto/identity.py"
      provides: "Key generation and serialization"
      exports: ["generate_identity", "Identity"]
    - path: "src/crypto/fingerprint.py"
      provides: "Fingerprint generation"
      exports: ["generate_fingerprint", "format_fingerprint"]
    - path: "src/storage/identity_store.py"
      provides: "Identity persistence"
      exports: ["save_identity", "load_identity", "has_identity"]
  key_links:
    - from: "src/storage/identity_store.py"
      to: "src/storage/dpapi.py"
      via: "Private keys encrypted with DPAPI"
      pattern: "dpapi_encrypt.*private"
    - from: "src/storage/identity_store.py"
      to: "src/storage/db.py"
      via: "Public keys stored in database"
      pattern: "INSERT INTO identity"
---

<objective>
Implement cryptographic identity generation with Ed25519/X25519 keys.

Purpose: Create the user's cryptographic identity - Ed25519 for signing (proving identity) and X25519 for key exchange (future encryption). Private keys are stored DPAPI-encrypted in the filesystem, while public keys go in the database.

Output: Identity module that generates, stores, and retrieves user identity.
</objective>

<execution_context>
@C:\Users\thete\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thete\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cryptographic-foundation-packaging/01-RESEARCH.md
@.planning/phases/01-cryptographic-foundation-packaging/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Cryptographic Identity Generation</name>
  <files>
    src/crypto/__init__.py
    src/crypto/identity.py
    src/crypto/fingerprint.py
  </files>
  <action>
Create cryptographic identity module:

1. Create `src/crypto/__init__.py`:
   - Export Identity, generate_identity from identity
   - Export generate_fingerprint, format_fingerprint from fingerprint

2. Create `src/crypto/fingerprint.py`:
```python
"""
SHA256 fingerprint generation for identity verification.

Fingerprints are used to verify contacts' identities out-of-band
(e.g., comparing fingerprints in person or over phone).
"""

import hashlib
from cryptography.hazmat.primitives.asymmetric import ed25519


def generate_fingerprint(public_key: ed25519.Ed25519PublicKey) -> str:
    """
    Generate SHA256 fingerprint of Ed25519 public key.

    Args:
        public_key: Ed25519 public key object

    Returns:
        Lowercase hex string of SHA256 hash (64 characters)
    """
    raw_bytes = public_key.public_bytes_raw()
    return hashlib.sha256(raw_bytes).hexdigest()


def format_fingerprint(fingerprint: str, group_size: int = 4) -> str:
    """
    Format fingerprint for human display.

    Args:
        fingerprint: 64-character hex string
        group_size: Characters per group (default 4)

    Returns:
        Formatted string like "a1b2 c3d4 e5f6 ..."
    """
    groups = [fingerprint[i:i+group_size] for i in range(0, len(fingerprint), group_size)]
    return ' '.join(groups)
```

3. Create `src/crypto/identity.py`:
```python
"""
Cryptographic identity management using Ed25519 and X25519 curves.

Ed25519: Signing key pair for identity verification
- Used to sign messages proving they came from you
- Public key serves as your unique identifier

X25519: Key exchange pair for encryption
- Used to establish shared secrets with contacts
- Enables end-to-end encrypted communication (Phase 3)

IMPORTANT: We generate SEPARATE Ed25519 and X25519 keys.
Do NOT convert Ed25519 to X25519 - cryptography library removed this support.
"""

from dataclasses import dataclass
from cryptography.hazmat.primitives.asymmetric import ed25519, x25519
from cryptography.hazmat.primitives import serialization

from src.crypto.fingerprint import generate_fingerprint


@dataclass
class Identity:
    """User's cryptographic identity."""

    # Ed25519 signing keys (PEM format for human-readable storage)
    ed25519_private_pem: bytes
    ed25519_public_pem: bytes

    # X25519 key exchange keys (raw bytes - 32 bytes each)
    x25519_private_raw: bytes
    x25519_public_raw: bytes

    # Derived values
    fingerprint: str
    display_name: str = "Anonymous"

    @property
    def ed25519_public_hex(self) -> str:
        """Get Ed25519 public key as hex for sharing."""
        key = serialization.load_pem_public_key(self.ed25519_public_pem)
        return key.public_bytes_raw().hex()

    @property
    def x25519_public_hex(self) -> str:
        """Get X25519 public key as hex."""
        return self.x25519_public_raw.hex()

    @property
    def shareable_id(self) -> str:
        """
        Get shareable identity string (Ed25519 public key).

        This is what users share to add each other as contacts.
        """
        return self.ed25519_public_hex


def generate_identity(display_name: str = "Anonymous") -> Identity:
    """
    Generate new cryptographic identity.

    Creates:
    - Ed25519 key pair for signing
    - X25519 key pair for key exchange
    - SHA256 fingerprint for verification

    Args:
        display_name: User's display name

    Returns:
        Identity object with all keys and metadata
    """
    # Generate Ed25519 signing key pair
    ed_private = ed25519.Ed25519PrivateKey.generate()
    ed_public = ed_private.public_key()

    # Serialize Ed25519 keys to PEM format
    ed_private_pem = ed_private.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()  # DPAPI handles encryption
    )
    ed_public_pem = ed_public.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    # Generate X25519 key exchange pair
    x_private = x25519.X25519PrivateKey.generate()
    x_public = x_private.public_key()

    # X25519 keys as raw bytes (32 bytes each)
    x_private_raw = x_private.private_bytes_raw()
    x_public_raw = x_public.public_bytes_raw()

    # Generate fingerprint from Ed25519 public key
    fingerprint = generate_fingerprint(ed_public)

    return Identity(
        ed25519_private_pem=ed_private_pem,
        ed25519_public_pem=ed_public_pem,
        x25519_private_raw=x_private_raw,
        x25519_public_raw=x_public_raw,
        fingerprint=fingerprint,
        display_name=display_name
    )
```

NOTE: Private keys are stored as bytes, NOT saved to database. The identity_store handles DPAPI encryption.
  </action>
  <verify>
    Identity generates: `python -c "from src.crypto.identity import generate_identity; i = generate_identity(); print(f'Fingerprint: {i.fingerprint[:16]}...'); print(f'Public key: {i.shareable_id[:16]}...')"`
  </verify>
  <done>
    - generate_identity() creates Ed25519 and X25519 key pairs
    - Identity dataclass holds all key material and metadata
    - Fingerprint is SHA256 of Ed25519 public key (64 hex chars)
    - shareable_id property returns Ed25519 public key hex
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Identity Storage</name>
  <files>
    src/storage/identity_store.py
  </files>
  <action>
Create identity storage with DPAPI-encrypted private keys:

1. Create `src/storage/identity_store.py`:
```python
"""
Identity persistence with secure key storage.

Storage model:
- Private keys: DPAPI-encrypted in filesystem (%APPDATA%/DiscordOpus/identity.key)
- Public keys: Stored in SQLCipher database (for reference)

This separation ensures that database compromise doesn't expose private keys,
and filesystem compromise doesn't expose contact data.
"""

import os
import json
from typing import Optional

from src.crypto.identity import Identity, generate_identity
from src.storage.dpapi import dpapi_encrypt, dpapi_decrypt
from src.storage.paths import get_identity_key_path
from src.storage.db import get_database


def has_identity() -> bool:
    """Check if user has generated an identity."""
    return os.path.exists(get_identity_key_path())


def save_identity(identity: Identity) -> None:
    """
    Save identity to secure storage.

    Private keys are DPAPI-encrypted in filesystem.
    Public keys are stored in SQLCipher database.

    Args:
        identity: Identity object to save
    """
    # Save private keys to DPAPI-encrypted file
    private_data = {
        'ed25519_private_pem': identity.ed25519_private_pem.decode('utf-8'),
        'x25519_private_raw': identity.x25519_private_raw.hex(),
        'version': 1
    }
    private_json = json.dumps(private_data).encode('utf-8')
    encrypted_private = dpapi_encrypt(private_json)

    key_path = get_identity_key_path()
    os.makedirs(os.path.dirname(key_path), exist_ok=True)

    with open(key_path, 'wb') as f:
        f.write(encrypted_private)

    # Save public data to database
    db = get_database()
    db.execute("""
        INSERT OR REPLACE INTO identity
        (id, ed25519_public_pem, x25519_public_hex, display_name, fingerprint)
        VALUES (1, ?, ?, ?, ?)
    """, (
        identity.ed25519_public_pem.decode('utf-8'),
        identity.x25519_public_hex,
        identity.display_name,
        identity.fingerprint
    ))
    db.commit()


def load_identity() -> Optional[Identity]:
    """
    Load identity from secure storage.

    Returns:
        Identity object if exists, None otherwise
    """
    key_path = get_identity_key_path()

    if not os.path.exists(key_path):
        return None

    # Load and decrypt private keys
    with open(key_path, 'rb') as f:
        encrypted_private = f.read()

    private_json = dpapi_decrypt(encrypted_private)
    private_data = json.loads(private_json.decode('utf-8'))

    # Load public data from database
    db = get_database()
    row = db.execute("""
        SELECT ed25519_public_pem, x25519_public_hex, display_name, fingerprint
        FROM identity WHERE id = 1
    """).fetchone()

    if row is None:
        return None

    ed_public_pem, x_public_hex, display_name, fingerprint = row

    return Identity(
        ed25519_private_pem=private_data['ed25519_private_pem'].encode('utf-8'),
        ed25519_public_pem=ed_public_pem.encode('utf-8'),
        x25519_private_raw=bytes.fromhex(private_data['x25519_private_raw']),
        x25519_public_raw=bytes.fromhex(x_public_hex),
        fingerprint=fingerprint,
        display_name=display_name
    )


def update_display_name(name: str) -> None:
    """
    Update identity display name.

    Args:
        name: New display name
    """
    db = get_database()
    db.execute("UPDATE identity SET display_name = ? WHERE id = 1", (name,))
    db.commit()


def get_or_create_identity(display_name: str = "Anonymous") -> Identity:
    """
    Get existing identity or create new one.

    Args:
        display_name: Display name for new identity (ignored if exists)

    Returns:
        User's cryptographic identity
    """
    identity = load_identity()

    if identity is None:
        identity = generate_identity(display_name)
        save_identity(identity)

    return identity
```

2. Update `src/storage/__init__.py` to export identity_store functions:
   - has_identity, save_identity, load_identity, update_display_name, get_or_create_identity

CRITICAL from research:
- Private keys stored in filesystem (identity.key), NOT in database
- This separation provides defense-in-depth
  </action>
  <verify>
    Identity roundtrip works: `python -c "from src.storage.identity_store import get_or_create_identity, load_identity; i1 = get_or_create_identity('Test'); i2 = load_identity(); assert i1.fingerprint == i2.fingerprint; print('Identity storage OK')"`
  </verify>
  <done>
    - save_identity() stores private keys DPAPI-encrypted in filesystem
    - save_identity() stores public keys in SQLCipher database
    - load_identity() reconstructs Identity from both sources
    - get_or_create_identity() handles first-run key generation
    - update_display_name() modifies name without touching keys
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. generate_identity() creates valid Ed25519/X25519 key pairs
2. Fingerprint is 64-character hex string
3. save_identity()/load_identity() roundtrip preserves all data
4. Private keys stored in %APPDATA%/DiscordOpus/identity.key (DPAPI-encrypted)
5. Public keys stored in database (identity table)
</verification>

<success_criteria>
- Identity generation creates Ed25519 and X25519 keys
- Fingerprint is SHA256 of Ed25519 public key
- Private keys are DPAPI-encrypted in filesystem (not database)
- Public keys are stored in SQLCipher database
- Identity persists across process restarts
</success_criteria>

<output>
After completion, create `.planning/phases/01-cryptographic-foundation-packaging/01-03-SUMMARY.md`
</output>
