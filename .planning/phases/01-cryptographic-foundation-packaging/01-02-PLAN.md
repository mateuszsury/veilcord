---
phase: 01-cryptographic-foundation-packaging
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/__init__.py
  - src/storage/dpapi.py
  - src/storage/db.py
  - src/storage/paths.py
autonomous: true

must_haves:
  truths:
    - "DPAPI can encrypt and decrypt 32-byte keys"
    - "SQLCipher database opens with DPAPI-protected key"
    - "Database key is created on first run and reused thereafter"
  artifacts:
    - path: "src/storage/dpapi.py"
      provides: "DPAPI encrypt/decrypt functions"
      exports: ["dpapi_encrypt", "dpapi_decrypt"]
    - path: "src/storage/db.py"
      provides: "SQLCipher database connection"
      exports: ["init_database", "get_database"]
    - path: "src/storage/paths.py"
      provides: "Application data paths"
      exports: ["get_app_data_dir", "get_db_path", "get_key_path"]
  key_links:
    - from: "src/storage/db.py"
      to: "src/storage/dpapi.py"
      via: "get_or_create_db_key uses dpapi_decrypt"
      pattern: "dpapi_decrypt"
    - from: "src/storage/db.py"
      to: "SQLCipher PRAGMA"
      via: "PRAGMA key must be first operation"
      pattern: "PRAGMA key.*BEFORE"
---

<objective>
Implement secure storage foundation with Windows DPAPI and SQLCipher.

Purpose: Establish the secure storage layer that protects all sensitive data. DPAPI encrypts the database key, SQLCipher encrypts the database. This layered approach means no secrets are ever stored in plaintext.

Output: Working DPAPI encryption module and SQLCipher database initialization.
</objective>

<execution_context>
@C:\Users\thete\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thete\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cryptographic-foundation-packaging/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Application Paths Module</name>
  <files>
    src/storage/__init__.py
    src/storage/paths.py
  </files>
  <action>
Create storage module with application paths:

1. Create `src/storage/__init__.py`:
   - Export get_app_data_dir, get_db_path, get_key_path, get_identity_key_path
   - Export dpapi_encrypt, dpapi_decrypt
   - Export init_database, get_database

2. Create `src/storage/paths.py`:
   - `get_app_data_dir()`: Returns %APPDATA%/DiscordOpus/, creates if not exists
   - `get_db_path()`: Returns path to data.db in app data dir
   - `get_key_path()`: Returns path to db.key (DPAPI-encrypted database key)
   - `get_identity_key_path()`: Returns path to identity.key (DPAPI-encrypted private keys)

Use `os.getenv('APPDATA')` for Windows compatibility.
Use `os.makedirs(path, exist_ok=True)` to ensure directories exist.

Include docstrings explaining what each path is for.
  </action>
  <verify>
    Module imports: `python -c "from src.storage.paths import get_app_data_dir; print(get_app_data_dir())"`
  </verify>
  <done>
    - src/storage/paths.py has all path functions
    - get_app_data_dir() returns valid Windows path
    - All functions create parent directories if needed
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement DPAPI Encryption Module</name>
  <files>
    src/storage/dpapi.py
  </files>
  <action>
Implement Windows DPAPI wrapper for credential encryption:

1. Create `src/storage/dpapi.py`:

```python
"""
Windows DPAPI encryption for secure key storage.

DPAPI (Data Protection API) encrypts data using the Windows user's credentials.
Keys encrypted with DPAPI can only be decrypted by the same Windows user account.

WARNING: DPAPI keys are tied to the Windows user profile. If the user reinstalls
Windows or the profile is corrupted, DPAPI-encrypted data becomes unrecoverable.
Always implement password-based backup (see crypto/backup.py).
"""

import win32crypt
from typing import bytes


def dpapi_encrypt(plaintext: bytes) -> bytes:
    """
    Encrypt data using Windows DPAPI (current user scope).

    Args:
        plaintext: Raw bytes to encrypt

    Returns:
        DPAPI-encrypted blob (includes internal metadata for decryption)
    """
    encrypted = win32crypt.CryptProtectData(
        plaintext,
        None,  # Description (optional, stored in plaintext)
        None,  # Optional entropy (additional password)
        None,  # Reserved
        None,  # Prompt struct (None = no UI)
        0      # Flags (0 = current user scope)
    )
    return encrypted


def dpapi_decrypt(encrypted: bytes) -> bytes:
    """
    Decrypt DPAPI-protected data.

    Args:
        encrypted: DPAPI blob from dpapi_encrypt()

    Returns:
        Original plaintext bytes

    Raises:
        Exception: If decryption fails (wrong user, corrupted data)
    """
    description, decrypted = win32crypt.CryptUnprotectData(
        encrypted,
        None,  # Optional entropy (must match encryption)
        None,  # Reserved
        None,  # Prompt struct
        0      # Flags
    )
    return decrypted
```

2. Add type hints and comprehensive docstrings
3. Include warning about DPAPI limitations in module docstring

CRITICAL: Do not add optional entropy parameter - keep it simple. Entropy would require storing another secret.
  </action>
  <verify>
    DPAPI roundtrip works: `python -c "from src.storage.dpapi import dpapi_encrypt, dpapi_decrypt; data = b'test'; assert dpapi_decrypt(dpapi_encrypt(data)) == data; print('DPAPI OK')"`
  </verify>
  <done>
    - dpapi_encrypt() encrypts bytes using Windows DPAPI
    - dpapi_decrypt() decrypts DPAPI blobs
    - Roundtrip test passes (encrypt then decrypt returns original)
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement SQLCipher Database Module</name>
  <files>
    src/storage/db.py
  </files>
  <action>
Implement SQLCipher database initialization with DPAPI-protected key:

1. Create `src/storage/db.py`:

```python
"""
SQLCipher encrypted database with DPAPI-protected key.

Security model:
1. Database key (32 random bytes) is generated on first run
2. Key is encrypted with DPAPI and stored in db.key file
3. SQLCipher uses the key to encrypt/decrypt the database
4. All queries go through encrypted database - no plaintext on disk

CRITICAL: PRAGMA key MUST be the first operation after sqlite3.connect().
Any query before PRAGMA key will fail or corrupt the database.
"""

import sqlite3
import os
from typing import Optional

from src.storage.paths import get_db_path, get_key_path, get_app_data_dir
from src.storage.dpapi import dpapi_encrypt, dpapi_decrypt


# Module-level connection singleton
_db_connection: Optional[sqlite3.Connection] = None


def get_or_create_db_key() -> bytes:
    """
    Get existing database key or create new one.

    The key is stored DPAPI-encrypted in the filesystem.
    DPAPI encryption is tied to the Windows user account.

    Returns:
        32-byte database encryption key
    """
    key_path = get_key_path()

    if os.path.exists(key_path):
        # Load and decrypt existing key
        with open(key_path, 'rb') as f:
            encrypted_key = f.read()
        return dpapi_decrypt(encrypted_key)
    else:
        # Generate new 32-byte key
        new_key = os.urandom(32)

        # Encrypt with DPAPI and save
        encrypted_key = dpapi_encrypt(new_key)

        # Ensure directory exists
        os.makedirs(os.path.dirname(key_path), exist_ok=True)

        with open(key_path, 'wb') as f:
            f.write(encrypted_key)

        return new_key


def init_database() -> sqlite3.Connection:
    """
    Initialize SQLCipher database with encryption.

    Creates database and schema if they don't exist.
    Uses DPAPI-protected key for encryption.

    Returns:
        SQLite connection object

    Raises:
        sqlite3.DatabaseError: If key is wrong or database corrupted
    """
    global _db_connection

    if _db_connection is not None:
        return _db_connection

    db_key = get_or_create_db_key()
    db_path = get_db_path()

    # Ensure directory exists
    os.makedirs(os.path.dirname(db_path), exist_ok=True)

    # Connect to database
    conn = sqlite3.connect(db_path)

    # CRITICAL: Set key BEFORE any other operations
    conn.execute(f"PRAGMA key = \"x'{db_key.hex()}'\"")

    # Set SQLCipher 4.x compatibility
    conn.execute("PRAGMA cipher_compatibility = 4")

    # Verify key is correct (this will fail if key is wrong)
    try:
        conn.execute("SELECT count(*) FROM sqlite_master")
    except sqlite3.DatabaseError as e:
        conn.close()
        raise sqlite3.DatabaseError(
            "Failed to open database. Key may be incorrect or database corrupted."
        ) from e

    # Create schema
    conn.execute("""
        CREATE TABLE IF NOT EXISTS identity (
            id INTEGER PRIMARY KEY CHECK (id = 1),
            ed25519_public_pem TEXT NOT NULL,
            x25519_public_hex TEXT NOT NULL,
            display_name TEXT NOT NULL DEFAULT 'Anonymous',
            fingerprint TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)

    conn.execute("""
        CREATE TABLE IF NOT EXISTS contacts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ed25519_public_pem TEXT UNIQUE NOT NULL,
            x25519_public_hex TEXT NOT NULL,
            display_name TEXT NOT NULL,
            fingerprint TEXT NOT NULL,
            verified INTEGER DEFAULT 0,
            added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)

    conn.commit()

    _db_connection = conn
    return conn


def get_database() -> sqlite3.Connection:
    """
    Get database connection, initializing if needed.

    Returns:
        Active SQLite connection
    """
    global _db_connection

    if _db_connection is None:
        return init_database()

    return _db_connection


def close_database():
    """Close database connection."""
    global _db_connection

    if _db_connection is not None:
        _db_connection.close()
        _db_connection = None
```

2. Note the CHECK constraint on identity table - ensures only one identity row
3. Include comprehensive docstrings explaining the security model

CRITICAL from research:
- PRAGMA key MUST be first operation after connect
- Use hex key format: x'...'
- cipher_compatibility = 4 for SQLCipher 4.x
  </action>
  <verify>
    Database initializes: `python -c "from src.storage.db import init_database; conn = init_database(); print('SQLCipher OK')"`
    Schema created: `python -c "from src.storage.db import get_database; conn = get_database(); tables = conn.execute(\"SELECT name FROM sqlite_master WHERE type='table'\").fetchall(); print(tables)"`
  </verify>
  <done>
    - get_or_create_db_key() generates or retrieves DPAPI-encrypted database key
    - init_database() creates SQLCipher database with correct PRAGMA ordering
    - Schema includes identity and contacts tables
    - Database file created in %APPDATA%/DiscordOpus/
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. DPAPI encrypt/decrypt roundtrip works
2. SQLCipher database opens with DPAPI-protected key
3. Database schema includes identity and contacts tables
4. Key file exists in %APPDATA%/DiscordOpus/db.key
5. Database file exists in %APPDATA%/DiscordOpus/data.db
</verification>

<success_criteria>
- dpapi_encrypt() and dpapi_decrypt() work correctly
- Database initializes without errors
- PRAGMA key is set before any queries (code review)
- identity and contacts tables exist in database
- All files stored in %APPDATA%/DiscordOpus/
</success_criteria>

<output>
After completion, create `.planning/phases/01-cryptographic-foundation-packaging/01-02-SUMMARY.md`
</output>
