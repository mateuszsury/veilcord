---
phase: 01-cryptographic-foundation-packaging
plan: 04
type: execute
wave: 2
depends_on: ["01-03"]
files_modified:
  - src/crypto/backup.py
autonomous: true

must_haves:
  truths:
    - "User can export identity with password protection"
    - "User can import identity backup to restore keys"
    - "Backup file is encrypted with Argon2id + ChaCha20Poly1305"
    - "Wrong password fails gracefully with clear error"
  artifacts:
    - path: "src/crypto/backup.py"
      provides: "Password-based key backup/restore"
      exports: ["export_backup", "import_backup", "BackupError"]
  key_links:
    - from: "src/crypto/backup.py"
      to: "Argon2id KDF"
      via: "Password derives encryption key"
      pattern: "Argon2id"
    - from: "src/crypto/backup.py"
      to: "ChaCha20Poly1305"
      via: "Authenticated encryption of key material"
      pattern: "ChaCha20Poly1305"
---

<objective>
Implement password-based key backup and restore using Argon2id.

Purpose: DPAPI keys are tied to the Windows user account. If the user reinstalls Windows or moves to a new machine, their identity is lost. Password-based backup allows recovery. This is a critical security feature from day one.

Output: Backup module that exports/imports encrypted key files.
</objective>

<execution_context>
@C:\Users\thete\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thete\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cryptographic-foundation-packaging/01-RESEARCH.md
@.planning/phases/01-cryptographic-foundation-packaging/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Argon2id Key Backup Export</name>
  <files>
    src/crypto/backup.py
  </files>
  <action>
Create password-based backup using Argon2id + ChaCha20Poly1305:

1. Create `src/crypto/backup.py`:
```python
"""
Password-based key backup using Argon2id and ChaCha20-Poly1305.

DPAPI-encrypted keys are tied to the Windows user account and cannot be
recovered if Windows is reinstalled. This module provides password-based
backup for identity recovery.

Security model:
1. User provides password
2. Argon2id derives 32-byte encryption key (memory-hard, resists GPU attacks)
3. ChaCha20-Poly1305 encrypts key material (authenticated encryption)
4. Backup includes salt, nonce, and KDF parameters for decryption

Argon2id parameters (RFC 9106 recommended for desktops):
- memory_cost: 65536 (64 MB)
- iterations: 3
- lanes: 4
- key length: 32 bytes

These parameters provide strong protection while completing in <1 second.
"""

import os
import json
from typing import Tuple

from argon2.low_level import hash_secret_raw, Type
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

from src.crypto.identity import Identity


class BackupError(Exception):
    """Error during backup export or import."""
    pass


# Argon2id parameters (RFC 9106 recommended)
ARGON2_MEMORY_COST = 65536  # 64 MB
ARGON2_ITERATIONS = 3
ARGON2_LANES = 4
ARGON2_KEY_LENGTH = 32

# Current backup format version
BACKUP_VERSION = 1


def _derive_key(password: str, salt: bytes) -> bytes:
    """
    Derive encryption key from password using Argon2id.

    Args:
        password: User's password
        salt: Random 32-byte salt

    Returns:
        32-byte encryption key
    """
    return hash_secret_raw(
        secret=password.encode('utf-8'),
        salt=salt,
        time_cost=ARGON2_ITERATIONS,
        memory_cost=ARGON2_MEMORY_COST,
        parallelism=ARGON2_LANES,
        hash_len=ARGON2_KEY_LENGTH,
        type=Type.ID  # Argon2id
    )


def export_backup(identity: Identity, password: str) -> str:
    """
    Export identity as password-protected backup.

    Args:
        identity: Identity to backup
        password: Password for encryption (min 8 characters recommended)

    Returns:
        JSON string containing encrypted backup

    Raises:
        BackupError: If backup creation fails
    """
    if len(password) < 4:
        raise BackupError("Password too short (minimum 4 characters)")

    try:
        # Generate random salt and nonce
        salt = os.urandom(32)
        nonce = os.urandom(12)  # 96-bit nonce for ChaCha20-Poly1305

        # Derive encryption key from password
        encryption_key = _derive_key(password, salt)

        # Prepare key material for encryption
        key_data = json.dumps({
            'ed25519_private_pem': identity.ed25519_private_pem.decode('utf-8'),
            'ed25519_public_pem': identity.ed25519_public_pem.decode('utf-8'),
            'x25519_private_raw': identity.x25519_private_raw.hex(),
            'x25519_public_raw': identity.x25519_public_raw.hex(),
            'fingerprint': identity.fingerprint,
            'display_name': identity.display_name
        }).encode('utf-8')

        # Encrypt with ChaCha20-Poly1305 (authenticated encryption)
        cipher = ChaCha20Poly1305(encryption_key)
        ciphertext = cipher.encrypt(nonce, key_data, None)

        # Create backup structure
        backup = {
            'version': BACKUP_VERSION,
            'kdf': 'argon2id',
            'kdf_params': {
                'memory_cost': ARGON2_MEMORY_COST,
                'iterations': ARGON2_ITERATIONS,
                'lanes': ARGON2_LANES
            },
            'salt': salt.hex(),
            'nonce': nonce.hex(),
            'ciphertext': ciphertext.hex()
        }

        return json.dumps(backup, indent=2)

    except Exception as e:
        raise BackupError(f"Failed to create backup: {e}") from e


def import_backup(backup_json: str, password: str) -> Identity:
    """
    Import identity from password-protected backup.

    Args:
        backup_json: JSON string from export_backup()
        password: Password used during export

    Returns:
        Restored Identity object

    Raises:
        BackupError: If import fails (wrong password, corrupted backup, etc.)
    """
    try:
        backup = json.loads(backup_json)
    except json.JSONDecodeError as e:
        raise BackupError("Invalid backup file format") from e

    # Version check
    version = backup.get('version')
    if version != BACKUP_VERSION:
        raise BackupError(f"Unsupported backup version: {version}")

    # KDF check
    if backup.get('kdf') != 'argon2id':
        raise BackupError(f"Unsupported KDF: {backup.get('kdf')}")

    try:
        # Extract components
        salt = bytes.fromhex(backup['salt'])
        nonce = bytes.fromhex(backup['nonce'])
        ciphertext = bytes.fromhex(backup['ciphertext'])

        # Re-derive encryption key
        kdf_params = backup['kdf_params']
        encryption_key = hash_secret_raw(
            secret=password.encode('utf-8'),
            salt=salt,
            time_cost=kdf_params['iterations'],
            memory_cost=kdf_params['memory_cost'],
            parallelism=kdf_params['lanes'],
            hash_len=ARGON2_KEY_LENGTH,
            type=Type.ID
        )

        # Decrypt
        cipher = ChaCha20Poly1305(encryption_key)
        try:
            plaintext = cipher.decrypt(nonce, ciphertext, None)
        except Exception:
            raise BackupError("Wrong password or corrupted backup")

        # Parse key data
        key_data = json.loads(plaintext.decode('utf-8'))

        return Identity(
            ed25519_private_pem=key_data['ed25519_private_pem'].encode('utf-8'),
            ed25519_public_pem=key_data['ed25519_public_pem'].encode('utf-8'),
            x25519_private_raw=bytes.fromhex(key_data['x25519_private_raw']),
            x25519_public_raw=bytes.fromhex(key_data['x25519_public_raw']),
            fingerprint=key_data['fingerprint'],
            display_name=key_data['display_name']
        )

    except BackupError:
        raise
    except Exception as e:
        raise BackupError(f"Failed to import backup: {e}") from e
```

2. Update `src/crypto/__init__.py` to export:
   - export_backup, import_backup, BackupError

CRITICAL from research:
- Argon2id (not Argon2i or Argon2d) for balanced GPU resistance
- ChaCha20Poly1305 for authenticated encryption (detects tampering)
- Fresh random nonce for EVERY export (never reuse)
- Parameters: 64MB memory, 3 iterations, 4 lanes (RFC 9106 desktop recommendation)
  </action>
  <verify>
    Backup roundtrip: `python -c "from src.crypto.identity import generate_identity; from src.crypto.backup import export_backup, import_backup; i = generate_identity('Test'); backup = export_backup(i, 'testpass'); i2 = import_backup(backup, 'testpass'); assert i.fingerprint == i2.fingerprint; print('Backup OK')"`
    Wrong password fails: `python -c "from src.crypto.identity import generate_identity; from src.crypto.backup import export_backup, import_backup, BackupError; i = generate_identity(); backup = export_backup(i, 'correct'); try: import_backup(backup, 'wrong'); print('FAIL: should error'); except BackupError as e: print(f'OK: {e}')"`
  </verify>
  <done>
    - export_backup() creates Argon2id + ChaCha20Poly1305 encrypted JSON
    - import_backup() restores Identity from backup with correct password
    - Wrong password raises BackupError with clear message
    - Backup includes version and KDF parameters for forward compatibility
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Backup File I/O Helpers</name>
  <files>
    src/crypto/backup.py (append)
  </files>
  <action>
Add file I/O helpers for backup export/import:

Append to `src/crypto/backup.py`:

```python
def export_backup_to_file(identity: Identity, password: str, file_path: str) -> None:
    """
    Export identity backup to file.

    Args:
        identity: Identity to backup
        password: Password for encryption
        file_path: Destination file path

    Raises:
        BackupError: If export or file write fails
    """
    backup_json = export_backup(identity, password)

    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(backup_json)
    except OSError as e:
        raise BackupError(f"Failed to write backup file: {e}") from e


def import_backup_from_file(file_path: str, password: str) -> Identity:
    """
    Import identity backup from file.

    Args:
        file_path: Source file path
        password: Password used during export

    Returns:
        Restored Identity object

    Raises:
        BackupError: If file read or import fails
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            backup_json = f.read()
    except OSError as e:
        raise BackupError(f"Failed to read backup file: {e}") from e

    return import_backup(backup_json, password)


def get_backup_info(backup_json: str) -> dict:
    """
    Get backup metadata without decrypting.

    Useful for showing backup info before import.

    Args:
        backup_json: JSON string from export_backup()

    Returns:
        Dict with version and KDF parameters

    Raises:
        BackupError: If backup format is invalid
    """
    try:
        backup = json.loads(backup_json)
        return {
            'version': backup.get('version'),
            'kdf': backup.get('kdf'),
            'kdf_params': backup.get('kdf_params')
        }
    except (json.JSONDecodeError, KeyError) as e:
        raise BackupError("Invalid backup file format") from e
```

Update exports in `src/crypto/__init__.py`:
- export_backup_to_file, import_backup_from_file, get_backup_info
  </action>
  <verify>
    File export works: `python -c "import tempfile; from src.crypto.identity import generate_identity; from src.crypto.backup import export_backup_to_file, import_backup_from_file; i = generate_identity(); f = tempfile.mktemp(suffix='.json'); export_backup_to_file(i, 'test', f); i2 = import_backup_from_file(f, 'test'); print('File I/O OK')"`
  </verify>
  <done>
    - export_backup_to_file() writes encrypted backup to specified path
    - import_backup_from_file() reads and decrypts backup from file
    - get_backup_info() extracts metadata without decryption
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. export_backup() creates valid encrypted JSON
2. import_backup() restores identity with correct password
3. Wrong password raises BackupError
4. File I/O helpers work correctly
5. Argon2id parameters match RFC 9106 recommendations
</verification>

<success_criteria>
- Backup uses Argon2id with memory_cost=65536, iterations=3, lanes=4
- ChaCha20Poly1305 provides authenticated encryption
- Backup includes version for forward compatibility
- Wrong password gives clear error message
- File export/import helpers work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-cryptographic-foundation-packaging/01-04-SUMMARY.md`
</output>
