---
phase: 01-cryptographic-foundation-packaging
plan: 06
type: execute
wave: 3
depends_on: ["01-03", "01-04", "01-05"]
files_modified:
  - src/api/__init__.py
  - src/api/bridge.py
  - src/main.py
  - src/storage/contacts.py
  - frontend/src/components/settings/SettingsPanel.tsx
  - frontend/src/components/settings/IdentitySection.tsx
  - frontend/src/components/settings/BackupSection.tsx
  - frontend/src/components/settings/ContactsSection.tsx
  - frontend/src/components/layout/MainPanel.tsx
autonomous: true

must_haves:
  truths:
    - "User can view their public key and fingerprint in settings"
    - "User can set and change display name"
    - "User can add contact by pasting public key"
    - "User can export and import key backup"
    - "User can verify contact fingerprint"
  artifacts:
    - path: "src/api/bridge.py"
      provides: "PyWebView API class exposed to JavaScript"
      exports: ["API"]
    - path: "src/storage/contacts.py"
      provides: "Contact CRUD operations"
      exports: ["add_contact", "get_contacts", "remove_contact"]
    - path: "frontend/src/components/settings/SettingsPanel.tsx"
      provides: "Settings UI"
      min_lines: 50
  key_links:
    - from: "src/api/bridge.py"
      to: "src/storage/identity_store.py"
      via: "get_identity calls load_identity"
      pattern: "load_identity"
    - from: "src/api/bridge.py"
      to: "src/crypto/backup.py"
      via: "export_backup and import_backup"
      pattern: "export_backup|import_backup"
    - from: "frontend/src/components/settings/SettingsPanel.tsx"
      to: "frontend/src/lib/pywebview.ts"
      via: "api.call for all operations"
      pattern: "api\\.call"
---

<objective>
Implement identity and contact management UI with full PyWebView bridge.

Purpose: Connect the React frontend to the Python backend through the PyWebView API. Users can manage their identity (view key, change name, backup/restore) and contacts (add by public key, verify fingerprint).

Output: Working settings panel with identity and contact management.
</objective>

<execution_context>
@C:\Users\thete\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thete\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cryptographic-foundation-packaging/01-RESEARCH.md
@.planning/phases/01-cryptographic-foundation-packaging/01-03-SUMMARY.md
@.planning/phases/01-cryptographic-foundation-packaging/01-04-SUMMARY.md
@.planning/phases/01-cryptographic-foundation-packaging/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Contact Storage and PyWebView API Bridge</name>
  <files>
    src/storage/contacts.py
    src/api/__init__.py
    src/api/bridge.py
    src/main.py
  </files>
  <action>
Create contact storage and the complete PyWebView API:

1. Create `src/storage/contacts.py`:
```python
"""
Contact storage in SQLCipher database.
"""

from typing import List, Optional
from dataclasses import dataclass
from cryptography.hazmat.primitives.asymmetric import ed25519
from cryptography.hazmat.primitives import serialization

from src.storage.db import get_database
from src.crypto.fingerprint import generate_fingerprint


@dataclass
class Contact:
    """Contact data."""
    id: int
    ed25519_public_pem: str
    x25519_public_hex: str
    display_name: str
    fingerprint: str
    verified: bool
    added_at: str


def get_contacts() -> List[Contact]:
    """Get all contacts."""
    db = get_database()
    rows = db.execute("""
        SELECT id, ed25519_public_pem, x25519_public_hex, display_name,
               fingerprint, verified, added_at
        FROM contacts
        ORDER BY display_name
    """).fetchall()

    return [
        Contact(
            id=row[0],
            ed25519_public_pem=row[1],
            x25519_public_hex=row[2],
            display_name=row[3],
            fingerprint=row[4],
            verified=bool(row[5]),
            added_at=row[6]
        )
        for row in rows
    ]


def get_contact(contact_id: int) -> Optional[Contact]:
    """Get contact by ID."""
    db = get_database()
    row = db.execute("""
        SELECT id, ed25519_public_pem, x25519_public_hex, display_name,
               fingerprint, verified, added_at
        FROM contacts WHERE id = ?
    """, (contact_id,)).fetchone()

    if row is None:
        return None

    return Contact(
        id=row[0],
        ed25519_public_pem=row[1],
        x25519_public_hex=row[2],
        display_name=row[3],
        fingerprint=row[4],
        verified=bool(row[5]),
        added_at=row[6]
    )


def add_contact(public_key_hex: str, display_name: str) -> Contact:
    """
    Add contact by Ed25519 public key.

    Args:
        public_key_hex: Ed25519 public key as hex string (64 chars)
        display_name: Display name for contact

    Returns:
        Created Contact object

    Raises:
        ValueError: If public key is invalid
    """
    # Parse and validate public key
    try:
        public_key_bytes = bytes.fromhex(public_key_hex)
        if len(public_key_bytes) != 32:
            raise ValueError("Public key must be 32 bytes")

        public_key = ed25519.Ed25519PublicKey.from_public_bytes(public_key_bytes)
    except Exception as e:
        raise ValueError(f"Invalid public key: {e}") from e

    # Generate fingerprint
    fingerprint = generate_fingerprint(public_key)

    # Serialize to PEM for storage
    public_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    ).decode('utf-8')

    # X25519 public key - we don't have it yet, use placeholder
    # Will be exchanged during connection in Phase 2
    x25519_hex = '0' * 64  # Placeholder

    db = get_database()
    cursor = db.execute("""
        INSERT INTO contacts (ed25519_public_pem, x25519_public_hex, display_name, fingerprint)
        VALUES (?, ?, ?, ?)
    """, (public_pem, x25519_hex, display_name, fingerprint))
    db.commit()

    return Contact(
        id=cursor.lastrowid,
        ed25519_public_pem=public_pem,
        x25519_public_hex=x25519_hex,
        display_name=display_name,
        fingerprint=fingerprint,
        verified=False,
        added_at=""  # SQLite default
    )


def remove_contact(contact_id: int) -> None:
    """Remove contact by ID."""
    db = get_database()
    db.execute("DELETE FROM contacts WHERE id = ?", (contact_id,))
    db.commit()


def set_contact_verified(contact_id: int, verified: bool) -> None:
    """Set contact verification status."""
    db = get_database()
    db.execute(
        "UPDATE contacts SET verified = ? WHERE id = ?",
        (1 if verified else 0, contact_id)
    )
    db.commit()


def update_contact_display_name(contact_id: int, name: str) -> None:
    """Update contact display name."""
    db = get_database()
    db.execute(
        "UPDATE contacts SET display_name = ? WHERE id = ?",
        (name, contact_id)
    )
    db.commit()
```

2. Create `src/api/__init__.py`:
```python
from src.api.bridge import API

__all__ = ['API']
```

3. Create `src/api/bridge.py`:
```python
"""
PyWebView API bridge - exposes Python methods to JavaScript.

All methods in this class are available as window.pywebview.api.method_name()
in the React frontend.

IMPORTANT: All methods should return JSON-serializable values (dict, list, str, int, bool, None).
Complex objects should be converted to dicts.
"""

from typing import Optional, List, Dict, Any

from src.storage.identity_store import (
    get_or_create_identity,
    load_identity,
    update_display_name,
    save_identity
)
from src.storage.contacts import (
    get_contacts as _get_contacts,
    add_contact as _add_contact,
    remove_contact as _remove_contact,
    set_contact_verified as _set_contact_verified,
    Contact
)
from src.crypto.backup import (
    export_backup,
    import_backup,
    BackupError
)
from src.crypto.identity import Identity
from src.crypto.fingerprint import format_fingerprint


class API:
    """
    PyWebView API class exposed to JavaScript.

    Usage in JavaScript:
        await window.pywebview.api.get_identity()
    """

    def _identity_to_dict(self, identity: Optional[Identity]) -> Optional[Dict[str, Any]]:
        """Convert Identity to JSON-serializable dict."""
        if identity is None:
            return None

        return {
            'publicKey': identity.shareable_id,
            'fingerprint': identity.fingerprint,
            'fingerprintFormatted': format_fingerprint(identity.fingerprint),
            'displayName': identity.display_name
        }

    def _contact_to_dict(self, contact: Contact) -> Dict[str, Any]:
        """Convert Contact to JSON-serializable dict."""
        return {
            'id': contact.id,
            'publicKey': contact.ed25519_public_pem,  # For display - could extract hex
            'fingerprint': contact.fingerprint,
            'fingerprintFormatted': format_fingerprint(contact.fingerprint),
            'displayName': contact.display_name,
            'verified': contact.verified,
            'addedAt': contact.added_at
        }

    # ========== Identity Methods ==========

    def get_identity(self) -> Optional[Dict[str, Any]]:
        """Get current identity or None if not created."""
        identity = load_identity()
        return self._identity_to_dict(identity)

    def generate_identity(self, display_name: str = "Anonymous") -> Dict[str, Any]:
        """Generate new identity (creates if doesn't exist)."""
        identity = get_or_create_identity(display_name)
        return self._identity_to_dict(identity)

    def update_display_name(self, name: str) -> None:
        """Update identity display name."""
        update_display_name(name)

    # ========== Backup Methods ==========

    def export_backup(self, password: str) -> Dict[str, Any]:
        """
        Export identity as encrypted backup.

        Returns:
            Dict with 'backup' key containing JSON string
        """
        identity = load_identity()
        if identity is None:
            raise ValueError("No identity to backup")

        backup_json = export_backup(identity, password)
        return {'backup': backup_json}

    def import_backup(self, backup_json: str, password: str) -> Dict[str, Any]:
        """
        Import identity from encrypted backup.

        Returns:
            Imported identity dict
        """
        try:
            identity = import_backup(backup_json, password)
            save_identity(identity)
            return self._identity_to_dict(identity)
        except BackupError as e:
            raise ValueError(str(e)) from e

    # ========== Contact Methods ==========

    def get_contacts(self) -> List[Dict[str, Any]]:
        """Get all contacts."""
        contacts = _get_contacts()
        return [self._contact_to_dict(c) for c in contacts]

    def add_contact(self, public_key: str, display_name: str) -> Dict[str, Any]:
        """
        Add contact by public key.

        Args:
            public_key: Ed25519 public key as hex string (64 chars)
            display_name: Name to show for this contact
        """
        contact = _add_contact(public_key, display_name)
        return self._contact_to_dict(contact)

    def remove_contact(self, contact_id: int) -> None:
        """Remove contact by ID."""
        _remove_contact(contact_id)

    def set_contact_verified(self, contact_id: int, verified: bool) -> None:
        """Set contact verification status."""
        _set_contact_verified(contact_id, verified)

    # ========== System Methods ==========

    def ping(self) -> str:
        """Test method to verify bridge is working."""
        return "pong"
```

4. Update `src/main.py`:
```python
"""
DiscordOpus - Secure P2P Messenger

Main application entry point.
"""

import sys
import webview

from src.api.bridge import API
from src.storage.db import init_database, close_database

# Debug mode - set to False for production
DEBUG = '--dev' in sys.argv


def main():
    # Initialize database
    init_database()

    # Create API instance
    api = API()

    # Determine URL
    if DEBUG:
        url = 'http://localhost:5173'  # Vite dev server
    else:
        url = 'frontend/dist/index.html'

    # Create window
    window = webview.create_window(
        'DiscordOpus',
        url,
        js_api=api,
        width=1200,
        height=800,
        min_size=(800, 600),
        resizable=True,
        background_color='#0a0a0f'  # Cosmic dark background
    )

    # Start application
    try:
        webview.start(debug=DEBUG)
    finally:
        close_database()


if __name__ == '__main__':
    main()
```

5. Update `src/storage/__init__.py` to export contacts module:
```python
from src.storage.paths import get_app_data_dir, get_db_path, get_key_path, get_identity_key_path
from src.storage.dpapi import dpapi_encrypt, dpapi_decrypt
from src.storage.db import init_database, get_database, close_database
from src.storage.identity_store import (
    has_identity,
    save_identity,
    load_identity,
    update_display_name,
    get_or_create_identity
)
from src.storage.contacts import (
    get_contacts,
    get_contact,
    add_contact,
    remove_contact,
    set_contact_verified,
    update_contact_display_name,
    Contact
)
```

CRITICAL from research:
- js_api parameter exposes API class to JavaScript
- All API methods must return JSON-serializable values
- DEBUG flag switches between dev server and dist
  </action>
  <verify>
    API can be imported: `python -c "from src.api.bridge import API; api = API(); print(api.ping())"`
    Main runs without crash: `python -c "from src.main import main; print('Main importable')"`
  </verify>
  <done>
    - Contact storage with CRUD operations in SQLCipher
    - API bridge with identity, backup, and contact methods
    - main.py creates PyWebView window with API
    - Debug mode switches between dev server and dist
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Settings Panel UI Components</name>
  <files>
    frontend/src/components/settings/SettingsPanel.tsx
    frontend/src/components/settings/IdentitySection.tsx
    frontend/src/components/settings/BackupSection.tsx
    frontend/src/components/settings/ContactsSection.tsx
    frontend/src/components/layout/MainPanel.tsx
  </files>
  <action>
Create the settings panel with all sections:

1. Create `frontend/src/components/settings/IdentitySection.tsx`:
```tsx
import { useState } from 'react';
import { motion } from 'framer-motion';
import { useIdentityStore } from '@/stores/identity';
import { api, getApi } from '@/lib/pywebview';

export function IdentitySection() {
  const identity = useIdentityStore((s) => s.identity);
  const setIdentity = useIdentityStore((s) => s.setIdentity);
  const [isEditingName, setIsEditingName] = useState(false);
  const [newName, setNewName] = useState('');
  const [copied, setCopied] = useState(false);

  const handleCopyPublicKey = async () => {
    if (identity?.publicKey) {
      await navigator.clipboard.writeText(identity.publicKey);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const handleSaveName = async () => {
    if (newName.trim()) {
      await api.call((a) => a.update_display_name(newName.trim()));
      const updated = await api.call((a) => a.get_identity());
      setIdentity(updated);
      setIsEditingName(false);
    }
  };

  const handleGenerateIdentity = async () => {
    const newIdentity = await api.call((a) => a.generate_identity('Anonymous'));
    setIdentity(newIdentity);
  };

  if (!identity) {
    return (
      <div className="bg-cosmic-surface rounded-lg p-6">
        <h3 className="text-lg font-semibold mb-4">Identity</h3>
        <p className="text-cosmic-muted mb-4">
          Generate your cryptographic identity to start using DiscordOpus.
        </p>
        <button
          onClick={handleGenerateIdentity}
          className="px-4 py-2 bg-cosmic-accent hover:bg-cosmic-accent-hover text-white rounded-md transition-colors"
        >
          Generate Identity
        </button>
      </div>
    );
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      className="bg-cosmic-surface rounded-lg p-6"
    >
      <h3 className="text-lg font-semibold mb-4">Your Identity</h3>

      {/* Display Name */}
      <div className="mb-4">
        <label className="block text-sm text-cosmic-muted mb-1">Display Name</label>
        {isEditingName ? (
          <div className="flex gap-2">
            <input
              type="text"
              value={newName}
              onChange={(e) => setNewName(e.target.value)}
              className="flex-1 bg-cosmic-bg border border-cosmic-border rounded-md px-3 py-2 text-cosmic-text focus:outline-none focus:border-cosmic-accent"
              placeholder="Enter display name"
              autoFocus
            />
            <button
              onClick={handleSaveName}
              className="px-3 py-2 bg-cosmic-accent hover:bg-cosmic-accent-hover text-white rounded-md"
            >
              Save
            </button>
            <button
              onClick={() => setIsEditingName(false)}
              className="px-3 py-2 bg-cosmic-border hover:bg-cosmic-muted/20 rounded-md"
            >
              Cancel
            </button>
          </div>
        ) : (
          <div className="flex items-center gap-2">
            <span className="text-cosmic-text">{identity.displayName}</span>
            <button
              onClick={() => {
                setNewName(identity.displayName);
                setIsEditingName(true);
              }}
              className="text-xs text-cosmic-muted hover:text-cosmic-accent"
            >
              Edit
            </button>
          </div>
        )}
      </div>

      {/* Public Key */}
      <div className="mb-4">
        <label className="block text-sm text-cosmic-muted mb-1">Public Key (Share this)</label>
        <div className="flex items-center gap-2">
          <code className="flex-1 bg-cosmic-bg border border-cosmic-border rounded-md px-3 py-2 text-xs font-mono text-cosmic-text overflow-x-auto">
            {identity.publicKey}
          </code>
          <button
            onClick={handleCopyPublicKey}
            className="px-3 py-2 bg-cosmic-border hover:bg-cosmic-muted/20 rounded-md text-sm"
          >
            {copied ? 'Copied!' : 'Copy'}
          </button>
        </div>
      </div>

      {/* Fingerprint */}
      <div>
        <label className="block text-sm text-cosmic-muted mb-1">Fingerprint (For verification)</label>
        <code className="block bg-cosmic-bg border border-cosmic-border rounded-md px-3 py-2 text-sm font-mono text-cosmic-text">
          {identity.fingerprintFormatted || identity.fingerprint}
        </code>
        <p className="text-xs text-cosmic-muted mt-1">
          Compare this with your contact in person to verify identity
        </p>
      </div>
    </motion.div>
  );
}
```

2. Create `frontend/src/components/settings/BackupSection.tsx`:
```tsx
import { useState, useRef } from 'react';
import { motion } from 'framer-motion';
import { api } from '@/lib/pywebview';
import { useIdentityStore } from '@/stores/identity';

export function BackupSection() {
  const identity = useIdentityStore((s) => s.identity);
  const setIdentity = useIdentityStore((s) => s.setIdentity);
  const [exportPassword, setExportPassword] = useState('');
  const [importPassword, setImportPassword] = useState('');
  const [status, setStatus] = useState<{ type: 'success' | 'error'; message: string } | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleExport = async () => {
    if (exportPassword.length < 4) {
      setStatus({ type: 'error', message: 'Password must be at least 4 characters' });
      return;
    }

    try {
      const result = await api.call((a) => a.export_backup(exportPassword));

      // Download as file
      const blob = new Blob([result.backup], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `discordopus-backup-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);

      setStatus({ type: 'success', message: 'Backup exported successfully' });
      setExportPassword('');
    } catch (err) {
      setStatus({ type: 'error', message: err instanceof Error ? err.message : 'Export failed' });
    }
  };

  const handleImportClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (importPassword.length < 4) {
      setStatus({ type: 'error', message: 'Enter the backup password first' });
      return;
    }

    try {
      const text = await file.text();
      const newIdentity = await api.call((a) => a.import_backup(text, importPassword));
      setIdentity(newIdentity);
      setStatus({ type: 'success', message: 'Identity restored successfully' });
      setImportPassword('');
    } catch (err) {
      setStatus({ type: 'error', message: err instanceof Error ? err.message : 'Import failed' });
    }

    // Reset file input
    e.target.value = '';
  };

  if (!identity) {
    return (
      <div className="bg-cosmic-surface rounded-lg p-6">
        <h3 className="text-lg font-semibold mb-4">Key Backup</h3>
        <p className="text-cosmic-muted">Generate an identity first to enable backup.</p>
      </div>
    );
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      className="bg-cosmic-surface rounded-lg p-6"
    >
      <h3 className="text-lg font-semibold mb-4">Key Backup</h3>
      <p className="text-sm text-cosmic-muted mb-4">
        Create a password-protected backup of your identity keys. Store it safely -
        you'll need it to recover your identity if you reinstall Windows.
      </p>

      {status && (
        <div
          className={`mb-4 p-3 rounded-md text-sm ${
            status.type === 'success'
              ? 'bg-green-900/30 text-green-400'
              : 'bg-red-900/30 text-red-400'
          }`}
        >
          {status.message}
        </div>
      )}

      {/* Export */}
      <div className="mb-6">
        <label className="block text-sm font-medium mb-2">Export Backup</label>
        <div className="flex gap-2">
          <input
            type="password"
            value={exportPassword}
            onChange={(e) => setExportPassword(e.target.value)}
            placeholder="Create backup password"
            className="flex-1 bg-cosmic-bg border border-cosmic-border rounded-md px-3 py-2 text-cosmic-text focus:outline-none focus:border-cosmic-accent"
          />
          <button
            onClick={handleExport}
            className="px-4 py-2 bg-cosmic-accent hover:bg-cosmic-accent-hover text-white rounded-md"
          >
            Export
          </button>
        </div>
      </div>

      {/* Import */}
      <div>
        <label className="block text-sm font-medium mb-2">Import Backup</label>
        <div className="flex gap-2">
          <input
            type="password"
            value={importPassword}
            onChange={(e) => setImportPassword(e.target.value)}
            placeholder="Enter backup password"
            className="flex-1 bg-cosmic-bg border border-cosmic-border rounded-md px-3 py-2 text-cosmic-text focus:outline-none focus:border-cosmic-accent"
          />
          <button
            onClick={handleImportClick}
            className="px-4 py-2 bg-cosmic-border hover:bg-cosmic-muted/20 rounded-md"
          >
            Import
          </button>
          <input
            ref={fileInputRef}
            type="file"
            accept=".json"
            onChange={handleFileChange}
            className="hidden"
          />
        </div>
      </div>
    </motion.div>
  );
}
```

3. Create `frontend/src/components/settings/ContactsSection.tsx`:
```tsx
import { useState } from 'react';
import { motion } from 'framer-motion';
import { useContactsStore } from '@/stores/contacts';
import { api } from '@/lib/pywebview';

export function ContactsSection() {
  const contacts = useContactsStore((s) => s.contacts);
  const addContact = useContactsStore((s) => s.addContact);
  const removeContact = useContactsStore((s) => s.removeContact);
  const updateContact = useContactsStore((s) => s.updateContact);

  const [publicKey, setPublicKey] = useState('');
  const [displayName, setDisplayName] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [showFingerprint, setShowFingerprint] = useState<number | null>(null);

  const handleAddContact = async () => {
    setError(null);

    if (!publicKey.trim()) {
      setError('Please enter a public key');
      return;
    }
    if (!displayName.trim()) {
      setError('Please enter a display name');
      return;
    }

    try {
      const contact = await api.call((a) =>
        a.add_contact(publicKey.trim(), displayName.trim())
      );
      addContact(contact);
      setPublicKey('');
      setDisplayName('');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to add contact');
    }
  };

  const handleRemoveContact = async (id: number) => {
    await api.call((a) => a.remove_contact(id));
    removeContact(id);
  };

  const handleToggleVerified = async (id: number, currentVerified: boolean) => {
    await api.call((a) => a.set_contact_verified(id, !currentVerified));
    updateContact(id, { verified: !currentVerified });
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      className="bg-cosmic-surface rounded-lg p-6"
    >
      <h3 className="text-lg font-semibold mb-4">Contacts</h3>

      {/* Add Contact Form */}
      <div className="mb-6 p-4 bg-cosmic-bg rounded-lg">
        <h4 className="text-sm font-medium mb-3">Add Contact</h4>
        {error && (
          <div className="mb-3 p-2 bg-red-900/30 text-red-400 rounded text-sm">
            {error}
          </div>
        )}
        <div className="space-y-3">
          <input
            type="text"
            value={publicKey}
            onChange={(e) => setPublicKey(e.target.value)}
            placeholder="Paste contact's public key"
            className="w-full bg-cosmic-surface border border-cosmic-border rounded-md px-3 py-2 text-cosmic-text text-sm focus:outline-none focus:border-cosmic-accent"
          />
          <input
            type="text"
            value={displayName}
            onChange={(e) => setDisplayName(e.target.value)}
            placeholder="Display name"
            className="w-full bg-cosmic-surface border border-cosmic-border rounded-md px-3 py-2 text-cosmic-text text-sm focus:outline-none focus:border-cosmic-accent"
          />
          <button
            onClick={handleAddContact}
            className="w-full px-4 py-2 bg-cosmic-accent hover:bg-cosmic-accent-hover text-white rounded-md text-sm"
          >
            Add Contact
          </button>
        </div>
      </div>

      {/* Contacts List */}
      <div>
        <h4 className="text-sm font-medium mb-3">
          Your Contacts ({contacts.length})
        </h4>
        {contacts.length === 0 ? (
          <p className="text-cosmic-muted text-sm">No contacts yet</p>
        ) : (
          <ul className="space-y-2">
            {contacts.map((contact) => (
              <li
                key={contact.id}
                className="p-3 bg-cosmic-bg rounded-lg"
              >
                <div className="flex items-center justify-between">
                  <div>
                    <div className="font-medium flex items-center gap-2">
                      {contact.displayName}
                      {contact.verified && (
                        <span className="text-xs bg-green-900/30 text-green-400 px-1.5 py-0.5 rounded">
                          Verified
                        </span>
                      )}
                    </div>
                    <div className="text-xs text-cosmic-muted mt-1">
                      {contact.fingerprint.slice(0, 16)}...
                    </div>
                  </div>
                  <div className="flex gap-2">
                    <button
                      onClick={() =>
                        setShowFingerprint(
                          showFingerprint === contact.id ? null : contact.id
                        )
                      }
                      className="text-xs text-cosmic-muted hover:text-cosmic-text"
                    >
                      Verify
                    </button>
                    <button
                      onClick={() => handleRemoveContact(contact.id)}
                      className="text-xs text-red-400 hover:text-red-300"
                    >
                      Remove
                    </button>
                  </div>
                </div>

                {/* Fingerprint verification */}
                {showFingerprint === contact.id && (
                  <motion.div
                    initial={{ height: 0, opacity: 0 }}
                    animate={{ height: 'auto', opacity: 1 }}
                    className="mt-3 pt-3 border-t border-cosmic-border"
                  >
                    <p className="text-xs text-cosmic-muted mb-2">
                      Compare this fingerprint with your contact in person:
                    </p>
                    <code className="block bg-cosmic-surface p-2 rounded text-xs font-mono break-all">
                      {contact.fingerprintFormatted || contact.fingerprint}
                    </code>
                    <button
                      onClick={() => handleToggleVerified(contact.id, contact.verified)}
                      className={`mt-2 text-xs px-2 py-1 rounded ${
                        contact.verified
                          ? 'bg-red-900/30 text-red-400'
                          : 'bg-green-900/30 text-green-400'
                      }`}
                    >
                      {contact.verified ? 'Mark as Unverified' : 'Mark as Verified'}
                    </button>
                  </motion.div>
                )}
              </li>
            ))}
          </ul>
        )}
      </div>
    </motion.div>
  );
}
```

4. Create `frontend/src/components/settings/SettingsPanel.tsx`:
```tsx
import { motion } from 'framer-motion';
import { IdentitySection } from './IdentitySection';
import { BackupSection } from './BackupSection';
import { ContactsSection } from './ContactsSection';

export function SettingsPanel() {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      className="p-6 max-w-2xl mx-auto space-y-6"
    >
      <h2 className="text-2xl font-semibold">Settings</h2>

      <IdentitySection />
      <BackupSection />
      <ContactsSection />
    </motion.div>
  );
}
```

5. Update `frontend/src/components/layout/MainPanel.tsx` to use SettingsPanel:
```tsx
import { motion } from 'framer-motion';
import { useUIStore } from '@/stores/ui';
import { useContactsStore } from '@/stores/contacts';
import { SettingsPanel } from '@/components/settings/SettingsPanel';

export function MainPanel() {
  const activePanel = useUIStore((s) => s.activePanel);
  const selectedContactId = useUIStore((s) => s.selectedContactId);
  const contacts = useContactsStore((s) => s.contacts);

  const selectedContact = contacts.find((c) => c.id === selectedContactId);

  return (
    <motion.main
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      className="flex-1 h-full bg-cosmic-bg flex flex-col overflow-hidden"
    >
      {activePanel === 'settings' ? (
        <div className="flex-1 overflow-y-auto">
          <SettingsPanel />
        </div>
      ) : selectedContact ? (
        <div className="flex-1 flex flex-col">
          {/* Chat header */}
          <div className="p-4 border-b border-cosmic-border">
            <h2 className="font-semibold">{selectedContact.displayName}</h2>
            <p className="text-xs text-cosmic-muted">
              {selectedContact.verified ? 'Verified' : 'Unverified'}
            </p>
          </div>
          {/* Chat messages - placeholder */}
          <div className="flex-1 p-4 overflow-y-auto">
            <p className="text-cosmic-muted text-center py-8">
              Chat functionality coming in Phase 3
            </p>
          </div>
          {/* Message input - placeholder */}
          <div className="p-4 border-t border-cosmic-border">
            <div className="bg-cosmic-surface rounded-lg p-3 text-cosmic-muted">
              Message input coming in Phase 3...
            </div>
          </div>
        </div>
      ) : (
        <div className="flex-1 flex items-center justify-center text-cosmic-muted">
          <div className="text-center">
            <p className="text-lg">Select a contact to start chatting</p>
            <p className="text-sm mt-2">Or add a new contact in Settings</p>
          </div>
        </div>
      )}
    </motion.main>
  );
}
```
  </action>
  <verify>
    TypeScript compiles: `cd frontend && npx tsc --noEmit`
    Components exist: `ls frontend/src/components/settings/*.tsx`
  </verify>
  <done>
    - IdentitySection shows public key, fingerprint, and editable display name
    - BackupSection has export/import with password protection
    - ContactsSection has add contact form and contact list with verification
    - SettingsPanel combines all sections
    - MainPanel renders SettingsPanel when activePanel is 'settings'
  </done>
</task>

<task type="auto">
  <name>Task 3: Rebuild Frontend and Test Integration</name>
  <files>
    frontend/dist/index.html (generated)
  </files>
  <action>
Rebuild frontend and verify the complete integration works:

1. Rebuild frontend:
```bash
cd frontend && npm run build
```

2. Test Python backend starts correctly:
```bash
python -c "from src.main import main; print('Backend ready')"
```

3. Verify API methods work:
```bash
python -c "
from src.api.bridge import API
from src.storage.db import init_database

init_database()
api = API()

# Test identity
identity = api.generate_identity('TestUser')
print(f'Identity: {identity[\"displayName\"]} - {identity[\"fingerprint\"][:16]}...')

# Test contacts
contact = api.add_contact('0' * 64, 'Test Contact')  # Placeholder key
print(f'Contact added: {contact[\"displayName\"]}')

contacts = api.get_contacts()
print(f'Total contacts: {len(contacts)}')

# Test backup
backup = api.export_backup('testpass')
print(f'Backup created: {len(backup[\"backup\"])} bytes')

print('All API methods work!')
"
```

NOTE: Full UI testing requires running the app with PyWebView, which will be verified in Plan 07.
  </action>
  <verify>
    Frontend builds: `cd frontend && npm run build && ls dist/index.html`
    API test passes: `python -c "from src.api.bridge import API; from src.storage.db import init_database; init_database(); api = API(); print(api.ping())"`
  </verify>
  <done>
    - Frontend builds successfully with all components
    - Python API bridge methods work correctly
    - Identity generation, contacts, and backup all functional
    - Ready for PyInstaller packaging
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Frontend builds without errors
2. Python API bridge exposes all required methods
3. Identity, backup, and contact methods work correctly
4. Settings UI has all three sections (Identity, Backup, Contacts)
5. Contact verification workflow functional
</verification>

<success_criteria>
- `npm run build` succeeds in frontend/
- API.get_identity() returns identity data
- API.export_backup() creates encrypted JSON
- API.add_contact() adds contact to database
- Settings panel shows identity, backup, and contacts sections
- Contact verification toggle works
</success_criteria>

<output>
After completion, create `.planning/phases/01-cryptographic-foundation-packaging/01-06-SUMMARY.md`
</output>
