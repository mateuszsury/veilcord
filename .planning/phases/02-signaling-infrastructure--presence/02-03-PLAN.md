---
phase: 02-signaling-infrastructure--presence
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/api/bridge.py
  - src/main.py
  - src/network/service.py
  - frontend/src/lib/pywebview.ts
autonomous: true

must_haves:
  truths:
    - "Signaling client starts automatically on app launch"
    - "Connection state changes notify the frontend"
    - "Presence updates from server update contact list"
    - "User can send status updates through API"
    - "Clean shutdown sends offline status"
  artifacts:
    - path: "src/network/service.py"
      provides: "Network service orchestration"
      exports: ["NetworkService", "start_network", "stop_network"]
    - path: "src/api/bridge.py"
      provides: "Network API methods"
      contains: "get_connection_state"
    - path: "frontend/src/lib/pywebview.ts"
      provides: "Network API types"
      contains: "ConnectionState"
  key_links:
    - from: "src/main.py"
      to: "src/network/service.py"
      via: "webview.start(func=start_network)"
      pattern: "start_network"
    - from: "src/api/bridge.py"
      to: "src/network/service.py"
      via: "API calls network service methods"
      pattern: "network_service"
    - from: "src/network/service.py"
      to: "src/network/signaling_client.py"
      via: "Creates and manages SignalingClient"
      pattern: "SignalingClient"
---

<objective>
Integrate signaling client with PyWebView bridge and start network on app launch.

Purpose: Connect network layer to frontend so UI can display connection status and receive presence updates.
Output: Network service that runs in background thread, API bridge extensions, frontend type definitions.
</objective>

<execution_context>
@C:\Users\thete\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thete\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-signaling-infrastructure--presence/02-RESEARCH.md
@.planning/phases/02-signaling-infrastructure--presence/02-01-SUMMARY.md
@.planning/phases/02-signaling-infrastructure--presence/02-02-SUMMARY.md

Existing code references:
@src/main.py - PyWebView app startup
@src/api/bridge.py - API class exposed to JavaScript
@frontend/src/lib/pywebview.ts - TypeScript API definitions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create network service orchestrator</name>
  <files>
    src/network/service.py
    src/network/__init__.py
  </files>
  <action>
    Create network service that orchestrates signaling and presence:

    1. **Create src/network/service.py**:
       - `NetworkService` class:
         - `__init__(window: webview.Window)` - Store window reference for JS callbacks
         - `_loop: asyncio.AbstractEventLoop | None` - Event loop for background thread
         - `_signaling: SignalingClient | None` - WebSocket client
         - `_presence: PresenceManager` - Presence state manager
         - `_state: ConnectionState` - Current connection state

         Methods:
         - `start()` - Called by webview.start(func=...) in background thread:
           - Create new asyncio event loop
           - Set as current event loop
           - Load signaling server URL from settings
           - Create SignalingClient with callbacks
           - Create PresenceManager with presence callback
           - Run event loop forever (asyncio.get_event_loop().run_forever())
         - `stop()` - Graceful shutdown:
           - Send offline status message
           - Stop signaling client
           - Stop event loop
         - `async _on_state_change(state: ConnectionState)` - Connection state callback:
           - Update _state
           - Notify frontend via window.evaluate_js()
         - `async _on_message(message: dict)` - Message handler:
           - Route presence_update to PresenceManager
           - Log unknown message types
         - `async _on_presence_change(public_key: str, status: str)` - Presence callback:
           - Notify frontend via window.evaluate_js()

         Sync methods for API bridge:
         - `get_connection_state() -> str` - Return current state as string
         - `get_signaling_server() -> str` - Return server URL from settings
         - `set_signaling_server(url: str) -> None` - Update server URL, reconnect
         - `get_user_status() -> str` - Delegate to PresenceManager
         - `set_user_status(status: str) -> None` - Delegate to PresenceManager, send update
         - `send_message(message: dict) -> None` - Queue message to send via signaling

       - Module-level singleton pattern:
         - `_service: NetworkService | None = None`
         - `start_network(window: webview.Window)` - Create service, call start()
         - `stop_network()` - Call service.stop()
         - `get_network_service() -> NetworkService` - Return singleton (raise if not started)

    2. **Update src/network/__init__.py**:
       - Export NetworkService, start_network, stop_network, get_network_service

    Frontend notification via window.evaluate_js():
    ```python
    # Notify connection state change
    self._window.evaluate_js(f'''
        window.dispatchEvent(new CustomEvent('discordopus:connection', {{
            detail: {{ state: "{state.value}" }}
        }}));
    ''')

    # Notify presence change
    self._window.evaluate_js(f'''
        window.dispatchEvent(new CustomEvent('discordopus:presence', {{
            detail: {{ publicKey: "{public_key}", status: "{status}" }}
        }}));
    ''')
    ```

    Important:
    - Store strong reference to asyncio tasks to prevent GC
    - Use asyncio.to_thread() for database operations
    - Handle case where window is not yet ready (store events, replay on ready)
  </action>
  <verify>
    - `python -c "from src.network.service import NetworkService; print('OK')"`
    - `python -c "from src.network import start_network, stop_network; print('OK')"`
  </verify>
  <done>
    NetworkService orchestrates signaling and presence with frontend notification
  </done>
</task>

<task type="auto">
  <name>Task 2: Update API bridge with network methods</name>
  <files>
    src/api/bridge.py
  </files>
  <action>
    Add network-related API methods to PyWebView bridge:

    1. **Update src/api/bridge.py**:
       Add imports:
       ```python
       from src.network.service import get_network_service
       from src.network.presence import UserStatus
       ```

       Add new methods to API class:

       ```python
       # ========== Network Methods ==========

       def get_connection_state(self) -> str:
           """Get current signaling connection state."""
           try:
               service = get_network_service()
               return service.get_connection_state()
           except RuntimeError:
               return "disconnected"  # Service not started yet

       def get_signaling_server(self) -> str:
           """Get configured signaling server URL."""
           service = get_network_service()
           return service.get_signaling_server()

       def set_signaling_server(self, url: str) -> None:
           """Set signaling server URL (will reconnect)."""
           service = get_network_service()
           service.set_signaling_server(url)

       def get_user_status(self) -> str:
           """Get user's presence status."""
           service = get_network_service()
           return service.get_user_status()

       def set_user_status(self, status: str) -> None:
           """Set user's presence status (online/away/busy/invisible)."""
           valid_statuses = ["online", "away", "busy", "invisible"]
           if status not in valid_statuses:
               raise ValueError(f"Invalid status: {status}. Must be one of {valid_statuses}")
           service = get_network_service()
           service.set_user_status(status)
       ```

       Also update _contact_to_dict() to include online status:
       ```python
       def _contact_to_dict(self, contact: Contact) -> Dict[str, Any]:
           """Convert Contact to JSON-serializable dict."""
           return {
               'id': contact.id,
               'publicKey': contact.ed25519_public_pem,
               'fingerprint': contact.fingerprint,
               'fingerprintFormatted': format_fingerprint(contact.fingerprint),
               'displayName': contact.display_name,
               'verified': contact.verified,
               'addedAt': contact.added_at,
               'onlineStatus': contact.online_status  # NEW
           }
       ```
  </action>
  <verify>
    - `python -c "from src.api.bridge import API; a = API(); print(a.get_connection_state())"`
    - Should print "disconnected" (service not started)
    - Verify wiring: `grep -q "get_network_service" src/api/bridge.py && echo "API wired to network service" || echo "MISSING network service wiring"`
    - Verify methods exist: `python -c "from src.api.bridge import API; a = API(); print(hasattr(a, 'get_connection_state') and hasattr(a, 'set_user_status') and hasattr(a, 'get_signaling_server'))"`
  </verify>
  <done>
    API bridge has network methods for connection state and user status
  </done>
</task>

<task type="auto">
  <name>Task 3: Update main.py to start network service</name>
  <files>
    src/main.py
  </files>
  <action>
    Modify main.py to start network service in background:

    1. **Update src/main.py**:
       - Import network service: `from src.network.service import start_network, stop_network`
       - After creating window, store reference for network service
       - Use webview.start(func=...) to run network in background thread
       - Add shutdown cleanup

       Updated main():
       ```python
       def main():
           # Initialize database
           init_database()

           # Create API instance
           api = API()

           # Determine URL
           if DEBUG:
               url = 'http://localhost:5173'
           else:
               url = 'frontend/dist/index.html'

           # Create window
           window = webview.create_window(
               'DiscordOpus',
               url,
               js_api=api,
               width=1200,
               height=800,
               min_size=(800, 600),
               resizable=True,
               background_color='#0a0a0f'
           )

           # Start application with network service in background
           def on_loaded():
               # This runs after window is created but before start() blocks
               pass

           try:
               # start_network runs in background thread
               webview.start(
                   func=lambda: start_network(window),
                   debug=DEBUG
               )
           finally:
               stop_network()
               close_database()
       ```

       Note: webview.start(func=...) runs the function in a separate thread while the GUI runs on main thread. The network service will be running its asyncio event loop in that background thread.
  </action>
  <verify>
    - `python -c "from src.main import main; print('Syntax OK')"`
    - Verify wiring: `grep -q "start_network" src/main.py && echo "main.py starts network" || echo "MISSING start_network call"`
    - Verify wiring: `grep -q "stop_network" src/main.py && echo "main.py stops network" || echo "MISSING stop_network call"`
    - Manual test: Run app and check console for connection attempts
  </verify>
  <done>
    App starts network service on launch and cleans up on shutdown
  </done>
</task>

<task type="auto">
  <name>Task 4: Update frontend TypeScript API types</name>
  <files>
    frontend/src/lib/pywebview.ts
  </files>
  <action>
    Add network API types to TypeScript definitions:

    1. **Update frontend/src/lib/pywebview.ts**:

       Add new types:
       ```typescript
       export type ConnectionState = 'disconnected' | 'connecting' | 'authenticating' | 'connected';
       export type UserStatus = 'online' | 'away' | 'busy' | 'invisible' | 'offline' | 'unknown';
       ```

       Update PyWebViewAPI interface:
       ```typescript
       export interface PyWebViewAPI {
         // ... existing methods ...

         // Network
         get_connection_state(): Promise<ConnectionState>;
         get_signaling_server(): Promise<string>;
         set_signaling_server(url: string): Promise<void>;
         get_user_status(): Promise<UserStatus>;
         set_user_status(status: UserStatus): Promise<void>;
       }
       ```

       Update ContactResponse interface:
       ```typescript
       export interface ContactResponse {
         id: number;
         publicKey: string;
         fingerprint: string;
         fingerprintFormatted: string;
         displayName: string;
         verified: boolean;
         addedAt: string;
         onlineStatus: UserStatus;  // NEW
       }
       ```

       Add event type declarations for custom events:
       ```typescript
       // Custom events dispatched by Python backend
       declare global {
         interface WindowEventMap {
           'discordopus:connection': CustomEvent<{ state: ConnectionState }>;
           'discordopus:presence': CustomEvent<{ publicKey: string; status: UserStatus }>;
         }
       }
       ```
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit`
    - Verify types: `grep -q "ConnectionState" frontend/src/lib/pywebview.ts && echo "ConnectionState type exists" || echo "MISSING ConnectionState type"`
    - Verify types: `grep -q "UserStatus" frontend/src/lib/pywebview.ts && echo "UserStatus type exists" || echo "MISSING UserStatus type"`
    - Verify API methods: `grep -q "get_connection_state" frontend/src/lib/pywebview.ts && echo "API method typed" || echo "MISSING API method"`
    - Should complete without type errors
  </verify>
  <done>
    TypeScript types updated for network API and events
  </done>
</task>

</tasks>

<verification>
1. Network service imports correctly:
   ```bash
   python -c "from src.network.service import NetworkService, start_network, stop_network; print('OK')"
   ```

2. API bridge has new methods:
   ```bash
   python -c "from src.api.bridge import API; a = API(); print(hasattr(a, 'get_connection_state') and hasattr(a, 'set_user_status'))"
   ```

3. TypeScript compiles:
   ```bash
   cd frontend && npx tsc --noEmit && echo "TypeScript OK"
   ```
</verification>

<success_criteria>
- Network service starts on app launch in background thread
- API bridge exposes connection state and user status methods
- Frontend receives connection and presence events
- TypeScript types are updated for new API
</success_criteria>

<output>
After completion, create `.planning/phases/02-signaling-infrastructure--presence/02-03-SUMMARY.md`
</output>
