---
phase: 02-signaling-infrastructure--presence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/network/__init__.py
  - src/network/signaling_client.py
  - src/network/auth.py
  - src/network/stun.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "WebSocket client connects to configurable wss:// server"
    - "Client auto-reconnects with exponential backoff on disconnect"
    - "Ed25519 challenge-response authentication succeeds"
  artifacts:
    - path: "src/network/signaling_client.py"
      provides: "WebSocket client with auto-reconnect"
      exports: ["SignalingClient", "ConnectionState"]
    - path: "src/network/auth.py"
      provides: "Ed25519 authentication helper"
      exports: ["create_auth_response", "verify_challenge"]
    - path: "src/network/stun.py"
      provides: "STUN server configuration"
      exports: ["get_ice_servers", "DEFAULT_STUN_SERVERS"]
  key_links:
    - from: "src/network/signaling_client.py"
      to: "src/network/auth.py"
      via: "authenticate() calls create_auth_response()"
      pattern: "create_auth_response"
    - from: "src/network/signaling_client.py"
      to: "src/storage/identity_store.py"
      via: "load_identity() for signing"
      pattern: "load_identity"
---

<objective>
Implement WebSocket signaling client with auto-reconnection and Ed25519 challenge-response authentication.

Purpose: Enable secure connection to signaling server for presence and future P2P coordination.
Output: Network module with SignalingClient class that auto-reconnects and authenticates using Ed25519 identity.
</objective>

<execution_context>
@C:\Users\thete\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thete\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-signaling-infrastructure--presence/02-RESEARCH.md
@.planning/phases/01-cryptographic-foundation-packaging/01-03-SUMMARY.md

Existing code references:
@src/storage/identity_store.py - Identity loading (load_identity returns Identity with ed25519_private_key)
@src/crypto/identity.py - Identity dataclass structure
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create network module with WebSocket signaling client</name>
  <files>
    src/network/__init__.py
    src/network/signaling_client.py
    src/network/auth.py
    requirements.txt
  </files>
  <action>
    Create the network module with WebSocket signaling client:

    1. **Update requirements.txt** - Add websockets>=16.0 for asyncio WebSocket client

    2. **Create src/network/__init__.py** - Module exports for SignalingClient, ConnectionState, auth functions

    3. **Create src/network/auth.py** - Ed25519 authentication helper:
       - `create_auth_response(challenge: bytes, private_key: Ed25519PrivateKey) -> dict` - Signs challenge and returns auth response dict with public_key and signature (base64 encoded)
       - Uses cryptography library Ed25519 (already installed from Phase 1)
       - Returns JSON-serializable dict: {"type": "auth_response", "public_key": "...", "signature": "..."}

    4. **Create src/network/signaling_client.py** - WebSocket client with auto-reconnect:
       - `ConnectionState` enum: DISCONNECTED, CONNECTING, AUTHENTICATING, CONNECTED
       - `SignalingClient` class with:
         - `__init__(server_url: str, on_state_change: Callable, on_message: Callable)`
         - `async start()` - Start connection loop in current event loop
         - `async stop()` - Graceful shutdown with offline status message
         - `async send(message: dict)` - Send JSON message
         - `async _connect_loop()` - Uses websockets async iterator for auto-reconnect
         - `async _authenticate(websocket)` - Handle challenge-response auth
         - `_on_message(data: str)` - Parse and route incoming messages
       - Message types to handle:
         - "auth_challenge" -> call _authenticate()
         - "auth_success" -> set state to CONNECTED
         - "auth_failure" -> log error, reconnect
         - Others -> pass to on_message callback
       - Use websockets.asyncio.client.connect() with:
         - ping_interval=20, ping_timeout=20 (default keepalive)
         - Built-in exponential backoff reconnection via async iterator pattern
       - Thread-safe state management (will be called from separate thread)

    Important implementation notes:
    - Do NOT use blocking operations in async handlers
    - Store strong reference to connection task (prevent GC)
    - Load identity via load_identity() from src/storage/identity_store
    - Identity.ed25519_private_key is the raw Ed25519PrivateKey object
    - Log connection state changes for debugging
  </action>
  <verify>
    - `python -c "from src.network import SignalingClient, ConnectionState; print('OK')"`
    - `python -c "from src.network.auth import create_auth_response; print('OK')"`
    - Verify SignalingClient has start(), stop(), send() methods
  </verify>
  <done>
    SignalingClient class exists with auto-reconnect and Ed25519 auth
  </done>
</task>

<task type="auto">
  <name>Task 2: Create STUN server configuration</name>
  <files>
    src/network/stun.py
    src/network/__init__.py
  </files>
  <action>
    Create STUN configuration module for Phase 3 P2P connections:

    1. **Create src/network/stun.py**:
       - `DEFAULT_STUN_SERVERS` constant list:
         - "stun:stun.l.google.com:19302"
         - "stun:stun1.l.google.com:19302"
       - `get_ice_servers(custom_servers: list[str] | None = None) -> list[dict]`
         - Returns list of ICE server configs for aiortc RTCConfiguration
         - If custom_servers provided, use those instead of defaults
         - Each config is dict with "urls" key: [{"urls": ["stun:..."]}]

    2. **Update src/network/__init__.py** - Add STUN exports:
       - Export get_ice_servers, DEFAULT_STUN_SERVERS

    Purpose: Pre-configure STUN for Phase 3. Not used in Phase 2 but having the config ready avoids duplication later.
  </action>
  <verify>
    - `python -c "from src.network import get_ice_servers, DEFAULT_STUN_SERVERS; print(get_ice_servers())"`
    - Should output list with Google STUN servers
  </verify>
  <done>
    STUN configuration module exists with default Google servers
  </done>
</task>

</tasks>

<verification>
1. All imports work without errors:
   ```bash
   python -c "from src.network import SignalingClient, ConnectionState, get_ice_servers"
   ```

2. SignalingClient instantiates:
   ```bash
   python -c "from src.network import SignalingClient; c = SignalingClient('wss://test.example', lambda s: None, lambda m: None); print('Created')"
   ```

3. Auth response generation works:
   ```bash
   python -c "from src.network.auth import create_auth_response; from src.crypto.identity import generate_identity; i = generate_identity(); r = create_auth_response(b'test', i.ed25519_private_key); print('public_key' in r and 'signature' in r)"
   ```
</verification>

<success_criteria>
- WebSocket client module exists with SignalingClient class
- Ed25519 challenge-response auth helper implemented
- STUN server configuration ready for Phase 3
- All imports and basic instantiation work
</success_criteria>

<output>
After completion, create `.planning/phases/02-signaling-infrastructure--presence/02-01-SUMMARY.md`
</output>
